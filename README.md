TB2_ANALISIS ESTADO DEL ARTE 

DATOS GENERALES 

 

 

Apellidos y nombres estudiante 1:  

Diego Ulises, Soto Quispe 

 

Código: U202214477 

Sección: 

11980 

Asesor metodológico: 

Yaneth Charito Vasquez Olivera 

Apellidos y nombres estudiante 2: 

Brenda Lucía, Gamio Upiachihua 

Código: U202120344 

Sección: 

11980 

Asesor metodológico: 

Yaneth Charito Vasquez Olivera 

Carrera profesional:	Ingeniería de Software 

 

Asesor Temático: Yaneth Charito Vasquez Olivera 

 

Título del tema de investigación 

Tema de tesis: Desarrollo de un sistema low-code para automatizar pruebas de seguridad móvil, aplicando OWASP MASVS (Mobile Application Security Verification Standard), en startups fintech de Lima.  

Estado del arte 

Prefacio 

Para el desarrollo de la presente investigación se efectuó una búsqueda exhaustiva en las bases de datos Scopus y Web of Science, con el propósito de identificar literatura científica actual y de alto impacto. Para ampliar la cobertura de resultados se emplearon palabras clave en inglés cuidadosamente seleccionadas, entre ellas: DevSecOps, mobile security, OWASP MASVS, NIST, penetration testing, vulnerability detection, low code, Android app, detection method, mobile application insecurity, scanner, mobile security framework y security testing, combinadas mediante conectores lógicos como AND para precisar y refinar la información.  

Los resultados se filtraron para considerar únicamente artículos científicos publicados entre 2022-2025, en idioma inglés, clasificados en las áreas de Computer Science e Engineering y limitados al tipo de documento article, garantizando así que las fuentes fueran relevantes y recientes. Finalmente, se verifico que todos los artículos seleccionados provinieran de revistas indexadas en los cuartiles Q1 o Q2, asegurando la solidez académica y la calidad de las publicaciones empleadas en el estado del arte.  

 

Para la segunda identificación de la literatura científica relevante asociada a herramientas y metodologías de aseguramiento en el desarrollo y prueba de aplicaciones móviles, se realizó una búsqueda exhaustiva en las bases de datos Scopus, Web of Sciencie y ScienceDirect. Se utilizaron palabras como vulnerability detection, mobile app security y deep learning security framework, combinadas mediante conectores lógicos AND y OR para optimizar la precisión de los resultados. Se establecieron criterios de inclusión que se restringieron la búsqueda a artículos científicos publicados entre los años del 2022 y 2025, en idioma inglés, clasificados en las áreas temáticas de Computer Science e Engineering y limitados al tipo de documento article. Asimismo, se priorizo la calidad académica mediante la selección exclusiva de publicación indexadas en revistas Q1 y Q2. Esta estrategia permitió recopilar estudios clave que fundamentan el marco conceptual de la investigación, especialmente en lo relacionado con metodologías seguras de desarrollo móvil y automatización DevSecOps. 

 

Para la tercera investigación fue centrada en la evaluación y detección de vulnerabilidades en aplicaciones Android y malware móvil, se llevó a cabo una revisión sistemática en las bases de datos Scopus, Web of Science y ScienceDirect. La estrategia de búsqueda incluyo términos clave como Android Vulnerability, inter-app communication, GUI-based testing, mutation testing, blockchain federated detection, dynamic evasive malware, static analysis, source code analysis, malware detection frameworks y machine learning security. Dichos términos fueron combinados con operadores booleanos AND y OR, ajustados mediante filtros que acotaron los resultados a artículos científicos publicados entre 2022 y 2025, escritos en inglés, dentro de las áreas de Computer Science e Engineering y clasificados en los cuartiles Q1 y Q2. Este proceso metodológico permitió reunir un conjunto de investigaciones altamente especializadas que contribuyen significativamente al planteamiento de solución, al ofrecer enfoques avanzados en pruebas metamórficas, federación blockchain y aprendizaje automático para el fortalecimiento de la ciberseguridad móvil.  

 

Para el abordaje de la cuarta categoría temática, se realizó una búsqueda especializada en las bases de datos Scopus, Web of Science y ScienceDirect, con el objetivo de identificar investigaciones recientes que apliquen modelos de aprendizaje automático y técnicas inteligentes de detección de amenazas en dispositivos android. La estrategia de búsqueda incluyo términos clave en inglés como Android malware detection, graph neural networks, active learning, semantic embedding, pre-training models, multi-feature classification, TTP mapping, cyber threat intelligence y static-dynamic analysis, los cuales fueron combinados mediante operadores lógicos AND y OR para maximizar la relevancia y especificidad de los resultados. Se aplicaron filtros para limitar la búsqueda a artículos científicos publicados entre 2022 y 2025, en idioma inglés, pertenecientes a las áreas de Computer Science e Engineering y clasificados dentro de revistas científicas Q1, garantizado para la detección de malware, lo cual resulta altamente pertinente como sustento del planteamiento de solución de esta investigación, orientado a la automatización de pruebas de seguridad bajo el enfoque DevSecOps.  

 

Para el abordaje de la quinta temática, se llevó a cabo una busqueda focalizada en las bases de datos de Scopus, Web of Science y ScienceDirect, con la finalidad de identificar investigaciones recientes que desarrollen enfoques avanzados para la detección de malware en Android mediante técnicas de aprendizaje automático y arquitecturas inteligentes. La estrategia de búsqueda incorpora términos especializados como Android malware detection, function call graph learning, explainable AI, lightweight deep learning models, mobile malware classification, federated learning security, overlay attack detection y heterogeneous graph modeling, combinados mediante los operadores logicos AND y OR para asegurar precisión y exhaustividad. Se aplicaron filtros para restringir la selección a artículos en inglés, publicados entre 2023 y 2025, pertenecientes a las áreas de Computer Science y Engineering e indexados en revistas Q1, lo cual permitió recuperar ocho estudios altamente pertinentes que incluyen análisis comparativos de algoritmos, detección basada en grafos sensibles, modelos explicables, arquitecturas ligeras, esquemas federados, identificación de ataques de superposición y grafos heterogéneos ponderados. Estos resultados constituyen un sustento solido para la propuesta de esta investigación orientada a la automatización de pruebas de seguridad bajo un enfoque DevSecOps.  

Resúmenes por Categoría 

Diagnóstico de vulnerabilidades y evaluación de riesgos en entornos Android y iOS   

 

Resumen artículo 1: Cybersecurity Conceptual Framework Applied to Edge Computing and Internet of Things Environments 

a) 

Aporte: Propone un framework conceptual de ciberseguridad que integra NIST Cybersecurity Framework (framework que organiza la seguridad en Identify, Protect, Detect, Respond, Recover y Govern de NIST 2.0) con prácticas SecDevOps (desarrollo ágil que incorpora seguridad desde el diseño), para guiar a desarrolladores en la creación de soluciones seguras en entorno Edge Computing e IoT. ​(Reyes-Acosta et al., 2025)​ 

b) 

Problema: Los entornos IoT y Edge presentan alta vulnerabilidad por su naturaleza distribuida, dispositivos con recursos limitados y carencia de estándares unificados, lo que incrementa ataques como malware, DDoS, MitM y errores humanos. Las medidas tradicionales o el NIST puro no se adaptan a arquitecturas ágiles y descentralizadas.  

c) 

Técnicas/Herramientas: Combina NIST CSF y SecDevOps mediante procesos Identify – Plan, Protect – Build/ Verify, Detect-Monitor y Respond & Recover. Incorpora seguridad en CI/CD (integración y entrega continua), pruebas SAST/DAST (análisis estático y dinámico del código), monitoreo SIEM (plataformas que recopilan y correlacionan eventos de seguridad), modelado de amenazas con STRIDE, PASTA, DREAD (métodos para identificar y priorizar riesgos). Utiliza además MITRE ATT&CK, base de datos de tácticas y técnicas de ataques reales. Se validó con una revisión de 36 fuentes y la evaluación de 35 expertos de ciberseguridad.  

d) 

Principal resultado: El framework fue aceptado por los expertos como pertinente y aplicable, evidenciando que reduce vulnerabilidades, mejora la detección de amenazas, automatiza parche de seguridad y facilita el cumplimiento normativo, reforzando la resiliencia en sectores críticos como ciudades inteligentes, salud y redes industriales.  

 

Resumen artículo 2: Detection of hidden privilege escalations in android 

a) 

Aporte: El articulo propone un método automatizado para detectar escalamiento de privilegios de orden n en aplicaciones Android, combinando análisis estático de código y manifiestos con modelos de Machine Learning para identificar cadenas complejas de delegación de permisos que escapan de las herramientas tradicionales. ​(El-Zawawy & Hamdy, 2025)​ 

b) 

Problema: En Android, las apps pueden colaborar para escalar privilegios mediante intents, broadcast y content providers, eludiendo el sistema de permisos. Las técnicas existentes solo cubren el escalamiento de primer o segundo orden, por lo que no detectan vulnerabilidades más profundas, dejando expuestos datos y recursos críticos.  

c) 

Técnicas/Herramientas: Se desarrolló un flujo en cuatro fases: extracción de características (permisos, intents, filtros) resolución de intents para clasificar rutas seguras o peligrosas, detección de cadenas de escalamiento de orden n y clasificación con machine learning (Decision Tree para intents, Random Forest para filtros, Logistic Regression para soluciones.) Se procesaron 4 000 aplicaciones (2 000 benignas y 2 000 maliciosas) del repositorio AndroiZoo, empleando Androguard (análisis de código Android), Scikit-learn (entrenamiento de modelos), Numpy y Pandas (procesamiento de datos y métricas) para análisis y validación.  

d) 

Principal resultado: El enfoque identificó 52 982 casos de escalamiento de privilegios de cuarto orden que no eran visibles con análisis de primer orden, alcanzando 100% de precisión en la resolución de intents y altos valores de exactitud y F1-score en intents y filtros, demostrando eficacia para detectar vulnerabilidades ocultados y reducir el riesgo de acceso no autorizados en el ecosistema Android.  

 

Resumen artículo 3: Identifying the Mutual Correlations and Evaluating the Weights of Factors and Consequences of Mobile Application Insecurity 

 

a) 

Aporte: Propone un método para evaluar el peso de los factores de inseguridad en aplicaciones móviles, incorporando las correlaciones entre factores y consecuencias. Basado en los 10 principales riesgos de OWASP (como almacenamiento inseguro, cifrado débil o riesgo de ingeniería inversa), emplea modelos ontologicos ponderados que relacionan causas y efectos para mejorar la predicción y evaluación de la seguridad. ​(Zaitseva et al., 2023)​ 

b) 

Problema: El crecimiento de aplicaciones móviles supera la capacidad de los métodos actuales para prevenir y medir vulnerabilidades, dejando expuestos a usuarios y empresas a robo de datos, fraude y perdidas de privacidad.  

c) 

Técnicas/Herramientas: Se elaboraron matrices de dependencia entre 10 factores y 15 consecuencias, se modelaron las relaciones con funciones de dependencia (f1-f15) y se calcularon pesos de influencia (MAIFW = {0.4 ipu, 0.5 ids, 0.3 iar, 0.3 iazr, 0.4 efr, 0.7 cfr, 0.5 pcq, 0.6 ide, 0.6 rer}) para cuantificar el riesgo  

d) 

Principal resultado: Se hallo que código falso (cfr) es el factor más crítico (peso 0.7), seguido de cifrado insuficiente (ide) y riesgo de ingeniería inversa (rer) (peso 0-6), por ser los que más consecuencias generan (hasta 7 y 6 respectivamente), permitiendo priorizar y anticipar vulnerabilidades en el desarrollo de apps móviles.  

 

Resumen artículo 4: Penterep: Comprehensive penetration with adaptable interactive checklist 

 

a) 

Aporte: Presenta Penterep, una plataforma de pruebas de penetración que integra checklists interactivos adaptables para guiar y verificar de forma completa la  seguridad. Combina test manuales y automatizados, asegura trazabilidad y genera reportes automáticos, complementando estándares como PTES, OWASP, NIST (frameworks internacionales para pruebas de penetración y buenas prácticas) y permite despliegue flexible en la nube o local. ​(Lazarov et al., 2025)​ 

b) 

Problema: Las metodologías y herramientas existentes no garantizan la cobertura total de vulnerabilidades, ya que las pruebas solo automatizadas no detectan fallos de lógica de negocio o que requieren inspección visual. Además, cada entorno (red, aplicación, web, infraestructura) necesita enfoques distintos, lo que dificulta un procedimiento unificado.  

c) 

Técnicas/Herramientas: Se desarrolló una metodología basada en checklists dinámicos, que agrupa pruebas por objetivo (autenticación, autorización, etc.), sugiere subpruebas según el tipo de recurso encontrado y enlaza vulnerabilidades prediseñadas con severidad y recomendaciones. Penterep incorpora un flujo de 5 fases (configuración, selección de metodología, prueba, análisis y reporte), integra tests manuales y automatizados mediante servidores propios (SAT) para ejecución controlada y Pentereptools (conjunto de herramientas de código abierto para escaneo y explotación), y permite trabajo colaborativo con registro centralizado de hallazgos.  

d) 

Principal resultado: En un estudio de caso sobre la app vulnerable OWASP Juice Shop, Penterep detecto 35 de 52 vulnerabilidades frente a solo 17 de Burp Suite y menos de 12 de otras herramientas, demostrando mayor cobertura y precisión. La combinación de checklist interactivo y validación manual redujo falso positivos y aseguro que ninguna prueba crítica quedaría sin ejecutar, validando su eficacia para pruebas de penetración completas.  

 

Resumen artículo 5: SCAnME – scanner comparative analysis and metrics for evaluation 

a) 

Aporte: Los autores proponen una metodología para evaluar y comparar scanners DAST (Dynamic Application Security Testing) para aplicaciones web. Esta metodología compara la funcionalidad, el rendimiento, la efectividad y calidad de reportes. Además de incluir plantillas que facilita el uso de SCAnME y la comparación objetiva de herramientas. (​Koman & Janiszewski, 2025)​ 

b) 

Problema: El creciente número de ciberataques contra aplicaciones web requiere que desarrolladores y profesionales de la seguridad corrijan vulnerabilidades y prevenir amenazas. Al haber variedades de scanners DAST, tanto gratuitos y comerciales, no existe una herramienta o metodología estandarizada para comparar estos scanners. Además, que la mayoría solo se centra en una o dos tipos de vulnerabilidades específicas.  

c) 

Técnicas/Herramientas:  

Metodología SCAnME: 

Funcionalidad: Evalúa la presencia de características claves: crawler (rastreador), fuzzer (para descubrir vulnerabilidades), autenticación, etc. 

Rendimiento: Mide la velocidad de escaneo y el número de vulnerabilidades encontradas. 

Efectividad: Compara la detección de vulnerabilidades, enfocándose en todas las categorías de OWASP Top 10. 

Calidad de informes: Revisa la claridad, la capacidad de reproducción de las vulnerabilidades, formatos de archivos disponibles, información del escáner, etc. 

d) 

Principal resultado: La evaluación reveló que los scanners DAST tienen una baja efectividad general, sobre todo para aplicaciones modernas. En el caso OWASP Juice Shop, el escáner más efectivo, solo logró un nivel de exactitud del 3,8% (4 vulnerabilidades de 106). Esto evidencia la necesidad de metodologías para evaluar herramientas de testing automatizado. 

 

Resumen artículo 6: An effective end-to-end android malware detection method 

a) 

Aporte: Los autores proponen una metodología de detección de malware en Android de extremo a extremo (MADRF-CNN). Esto con el objetivo de automatizar completamente la extracción de características, convirtiendo secciones críticas del archivo Dex (formato ejecutable nativo de las aplicaciones Android) en una imagen RGB. Esta imagen pasaría a ser clasificada por un modelo de aprendizaje profundo, específicamente para procesar datos visuales (CNN). ​(Zhu et al., 2023)​ 

b) 

Problema: Los métodos de detección de malware basados en características manuales (permisos, APIs) son fácilmente evadidos por técnicas de ofuscación (hacer que el código fuente sea difícil de entender para ser protegido contra ingeniería inversa) y tienen poca verificación del código. 

c) 

Técnicas/Herramientas: 

Preprocesamiento Inteligente de archivos Dex: Se eliminan las secciones de “header” (cabecera) y “data”, y ser conserva solo las secciones índices de alto valor. 

Generación de Imágenes RGB: Cada 6 caracteres hexadecimales del Dex preprocesado se convierte en un píxel RGB. 

Red Neuronal Personalizada (MADRF-CNN): Una Red Neuronal Personalizada que incorpora un bloque “MADRF” (Multi-scale Adaptive Diverse Receptive Fields) que aplica max pooling y average pooling (técnicas para reducir la dimensión espacial de las imágenes procesadas) simultáneamente en múltiples escalas para capturar dependencias de largo alcance dentro de la imagen. 

d) 

Principal resultado: Este método logró una precisión del 96,9% en un conjunto de datos de 3 925 aplicaciones (2 507 maliciosas, 1 417 benignas), superando a otros métodos basados en imágenes. La eliminación de secciones redundantes del Dex y el uso del pooling mejoraron el rendimiento entre 1-3 puntos porcentuales respecto a una CNN base. 

 

Resumen artículo 7: On The (In)Effectiveness of Static Logic Bomb Detection for Android Apps 

a) 

Aporte: Los autores implementan TSOPEN (una réplica de TRIGGER$COPE de código abierto, se usa para la detección de bombas lógicas en apps Android) para la realización de un estudio a gran escala para evaluar su efectividad real en escenarios automatizados. ​(Samhi & Bartel, 2022)​ 

b) 

Problema: Las técnicas ya existentes para detectar de manera automática las bombas lógicas (código malicioso oculto tras condiciones específicas) prometen una tasa muy baja de falsos positivos, pero no ha sido validada en entornos reales. 

c) 

Técnicas/Herramientas: 

TSOPEN: Implementación en Java de TRIGGER$COPE que utiliza Soot (convierte el código en una representación intermedia que permite construir estructuras como el ICFG) y FlowDroid (Extiende Soot para realizar análisis de flujo de datos) para modelar la aplicación y construir un grafo de flow de control. 

Ejecución Simbólica: Modela valores de objetos relacionados con tiempo, SMS, ubicación, enteros, cadenas. 

Recuperación de Predicados: Construye fórmulas lógicas para cada instrucción. 

Clasificación y Dependencias de control: Clasifica a los predicados como sospechosos y verifica si controlan la ejecución de métodos sensibles (ej. Enviar SMS, acceder a ubicación). 

Experimentos a Gran Escala: Se ejecuta TSOPEN en 508 122 APKs del conjunto de datos de AndroZoo. 

d) 

Principal resultado: Se analizaron 405 810 (79,9%) de 508 122 aplicaciones en un promedio de 21 segundos por análisis. Descubrieron que la tasa de falsos positivos reportado originalmente (menos del 0,3%) era inalcanzable en un escenario realista. Su análisis arrojó una tasa de entre 17-27% de falsos positivos. 

 

Resumen artículo 8: A risk estimation study of native code vulnerabilities in Android applications 

a) 

Aporte: Los autores proponen un método rápido y de bajo costo computacional para estimar la puntuación de riesgo de vulnerabilidades conocidas en el código nativo (C/C++), permite verificar si una aplicación contiene vulnerabilidades antes del lanzamiento de esta. El método asigna un puntaje de riesgo semi-cuantitativo a cada app analizada. ​(Sanna et al., 2024)​ 

b) 

Problema: La detección y evaluación de vulnerabilidades en las librerías nativas de Android es compleja. Además de consumir muchos recursos y fácilmente se pasa por alto, lo que hace que al final de lancen aplicaciones con vulnerabilidades conocidas. 

c) 

Técnicas/Herramientas: 

Extracción de librerías: Se extraen los archivos ELF (librerías nativas) del APK. 

Análisis con herramientas de Ingeniería de Requisitos (RE): Se usa “pwntools” y el comando “strings” de Linux para extraer los nombres de las funciones y cadenas de texto que contienen la versión de la librería. 

Asociación y Matching: Se utiliza el enfoque de “lista blanca” (estrategia que solo permite el acceso o ejecución entidades aprobadas) para asociar el ELF analizado con una librería de terceros conocida. 

Base de Datos CVEs (Vulnerabilidades y exposiciones comunes) Personalizada: Se construye una base de datos de CVEs procesando descriptores con NLP (aplicar técnicas de IA para analizar, interpretar y estructurar descripciones textuales) para extraer el nombre del producto, la versión afectada y la función vulnerable. 

Algoritmo de Evaluación de Riesgo: Se aplica un algoritmo semi-cuantitativo (basado en ISO 27005) que combina la puntuación de explotabilidad e impacto de la CVE encontrada con un factor de “incertidumbre”. 

d) 

Principal resultado: En un análisis a gran escala de 100 000 APKs, se encontró que alrededor de 40% (38 384 APKs) contenían código nativo. De esas aplicaciones, el 55% (24 000 aplicaciones) pertenecía a una de las 15 librerías populares analizadas y presentaba un nivel de riesgo MEDIO o ALTO. 

 

Integración de seguridad y metodologías DevSecOps en el desarrollo móvil 

Resumen artículo 9: Review of Techniques for Integrating Security in Software Development Lifecycle 

a) 

Aporte: El artículo ofrece una revisión sistemática reciente que depura la literatura a 100 estudios y organiza, como integrar seguridad en todas las fases del SDLC. Su contribución es doble: pone énfasis en cuantificar el riesgo con escalas numéricas para priorizar de forma objetiva y resalta la colaboración del equipo y la automatización (análisis de amenazas y pruebas de seguridad) como caminos prácticos. Además, plantea una agenda clara: mejorar la estimación de esfuerzo, validar métodos con checklists/datasets y elegir técnicas según el tipo de amenaza ​(Saeed et al., 2025)​.  

b) 

Problema: La seguridad suele abordarse tarde y de forma reactiva: se descuida en diseño, el testing se centra más en lo funcional que en lo seguro y faltan parámetros cuantificables para priorizar. Hay brechas de cultura y capacidades en los equipos, la estimación de esfuerzo para trata riesgos es imprecisa y cuesta encajar técnicas tradicionales en contextos Ágiles/DevOps si no se automatizan. También es difícil elegir el modelo adecuado para cada amenaza.  

c) 

Técnicas/Herramientas: Se describen de forma aplicada: modelado de amenazas y diseño seguro en planificación, codificación segura y revisiones de código en implementación, análisis estático y dinámico y pruebas de penetración en prueba de gestión de vulnerabilidades, monitoreo continuo y respuesta a incidentes en despliegues y mantenimiento. Para priorizar riesgos, usa FMEA (RPN = severidad x ocurrencia x detección), STRIDE, DREAD y Protection Poker (estimación colaborativa). En automatización se menciona herramientas de análisis y CI/CD y IA/ML para detectar vulnerabilidades y mejorar la estimación de esfuerzo.  

d) 

Principal resultado: Integrar la seguridad desde el inicio y medir el riesgo con métricas numéricas mejora la priorización y el uso de recursos, reduce los costos de correcciones tardías y enfoca las mitigaciones donde más impacto tienen. La automatización del análisis de amenazas y de las pruebas de seguridad aumentan la cobertura, la velocidad y ayuda a estandarizar el proceso. El uso de técnicas de IA eleva la detección de vulnerabilidades y la estimación, siempre que haya validación rigurosa de los modelos de la elección adecuada según la amenaza.  

 

Resumen artículo 10: What is discussed about Flutter on Stack Overflow (SO) question-and-answer (Q&A) website: An empirical study 

a) 

Aporte: Este articulo transforma 176 876 preguntas de Stack Overflow sobre Flutter en un mapa claro de 12 temas y con métricas objetivas de vistas, puntaje, tiempo a la respuesta y tasa sin respuesta aceptada, muestra qué interesa y qué cuesta más. Además, revela la evolución anual y la participación de usuarios, dando base a priorizar documentación, herramientas y contenidos formativos ​(Alanazi & Alfayez, 2024)​. 

b) 

Problema: No se sabía con datos donde se trababan más de los desarrolladores de Flutter ni cómo cambia ese panorama en el tiempo. El estudio identifica como gran obstáculo la instalación y la automatización de builds, que concentra más actividad y presenta más dificultad para resolverse, pese a exigir guías. También alerta de una caída de actividad en 2023 

c) 

Técnicas/Herramientas: Se extrajo el Data Dump de Stack Exchange y se filtraron preguntas con Flutter en el título, cuerpo y etiquetas. Se valido una muestra aleatoria con revisión independiente. El texto se limpió retirando HTML y URLs, se eliminaron stopwords con NLTK, se lematizó con spaCY y se generaron bigramas con Gensim. Los temas se obtuvieron con LDA y se nombraron mediante card sorting usando palabras clave y preguntas más representativas. Popularidad se medió con promedios de vistas y puntaje. Dificultad con porcentaje sin respuesta aceptada y mediana de tiempo a la aceptación. Se analizaron tendencias por año y aplicó correlación Kendall.  

d) 

Principal resultado: Los datos del estudio muestran que, en Stack Overflow, la configuración y automatización de compilaciones en Flutter concentran al mismo tiempo la mayor atención y dificultad. De las 176 876 preguntas realizadas analizadas y 12 temas identificados, este tópico reúne 22 765 y lidera en popularidad por su promedio de vistas cercano a 3 197 y su puntaje medio de 2,67. A la vez, es el más complejo: 72% de sus preguntas no obtiene una respuesta aceptada y la mediana de tiempo para lograrla es de 16 053 segundos, cerca de cuatro horas y media 

 

Resumen artículo 11: Towards the definition of a research agenda on mobile application testing based on a tertiary study 

a) 

Aporte: Ofrece una panorámica integrada y actual del área de pruebas de aplicaciones móviles al sintetizar 21 estudios secundarios, organiza el campo en una taxonomía clara de cuatro ejes (general, automatización, context-awareness y entorno), caracteriza objetivos de prueba y plataformas, y cierra con una agenda de investigación con 15 desafíos para orientar trabajos futuros ​(Kuroishi et al., 2024)​. 

b) 

Problema: La evidencia sobre pruebas móviles estaba dispersa y poco saturada, en un dominio especialmente complejo por la fragmentación de dispositivos y sistemas, múltiples sensores, variaciones de pantalla y uso de contexto. Faltaba un mapa confiable que mostrara que se ha hecho, como se ha evaluado y hacia donde avanzar.  

c) 

Técnicas/Herramientas: Se realizo un estudio terciario siguiendo el proceso de una revisión sistemática (planificación, ejecución y reporte). Hubo búsqueda automática sin restricción de año hasta marzo de 2023 en IEEE Xplore, ACM Digital Library, Scopus, SpringerLink, ScienceDirect, Engineering Village, Web of Science y Wiley con cadenas refinadas. La gestión y de duplicación se hizo con StArt, se aplicaron criterios explícitos de inclusión y exclusión, y se complementó con snowballing hacia atrás y hacia adelante usando Google Scholar. La extracción de datos se basó en un formulario que capturo tipo de estudio, tópicos, objetivos de prueba, plataformas y numero de primarios. La calidad se evaluó con el esquema DARE de cuatro preguntas con puntuación de 0 a 4. Se clasificaron los estudios por temas principales y específicos, por objetivos funcionales y no funcionales, y por plataformas Android o iOS. 

d) 

Principal resultado: El trabajo finalizo con 21 estudios seleccionados que en conjunto incluyen más de 1 300 trabajos primarios, Se observo que la mayoría se centra en pruebas de funcionalidades y en la plataforma Android, mientras que hay pocos estudios específicos para iOS. También se confirmó que las técnicas basadas en modelos son más empleadas y que la generación de casos de prueba, junto con la falta de herramientas adecuadas, siguen siendo los retos más importantes. Con estos hallazgos se definió una agenda de 15 desafíos clave para guiar las investigaciones futuras en pruebas de aplicaciones móviles.  

 

Resumen artículo 12: Test Code Flakiness in Mobile Apps: The Developer’s Perspective 

a) 

Aporte: La contribución principal es el cambio de enfoque en la investigación de flakiness. El estudio se distancia de la detección automática para centrarse en la experiencia directa y la perspectiva de los desarrollares de aplicaciones móviles, Esto proporciona insights empíricos sobre las estrategias manuales y heurísticas que emplean día a día para mitigar las pruebas inestables ​(Pontillo et al., 2024)​. 

b) 

Problema: Es la volatilidad o inestabilidad del código de prueba (test flakiness) en aplicaciones móviles. Consiste en que una prueba arroja resultados inconsistentes (pasa/falla) sin que el código de la aplicación cambie. Este fenómeno socava gravemente la confianza en las suites de pruebas automatizadas y causa una significativa pérdida de tiempo a los equipos de desarrollos.  

c) 

Técnicas/Herramientas: El articulo utiliza un estudio empírico a gran escala basado en la perspectiva del desarrollador. La principal técnica de recopilación de datos es la aplicación de encuestas y entrevistas a profesionales, complementada con análisis de sus repositorios, para entender sus prácticas, las causas que perciben y las soluciones que implementan para gestionar la volatilidad.  

d) 

Principal resultado: El resultado clave es una clasificación de las causas de flakiness más comunes en móviles, según la visión de los desarrolladores, destacando fallas ligados a la interfaz del usuario (UI), la concurrencia y las dependencias de red. El estudio también cuantifica el impacto en el esfuerzo de desarrollo y propone un conjunto de prácticas de refactorización altamente efectivas.  

 

Resumen artículo 13: Enhancing cloud-native DevSecOps: A Zero Trust approach for the financial sector 

a) 

Aporte: Este artículo ofrece un framework práctico para instituciones financieras, que estas implementen el modelo de seguridad Zero Trust en sus entornos cloud-native DevSecOps. El framework se enfoca en realizar un análisis de la relación entre políticas de seguridad que ya existen en DevSecOps y Zero Trust, la identificación de consideraciones clave para aplicar Zero Trust en cada etapa del ciclo de vida del desarrollo de software, y se formaliza con una propuesta con 7 dominios y 23 subcategorías, evaluado por 9 criterios ​(Shin et al., 2025)​. 

b) 

Problema: Dado el aumento de la superficie de ataque, debido a la transición a microservicios y pipelines de CI/CD, las limitaciones de la seguridad perimetral, la falta de guías concretas para Zero Trust, y la complejidad operativa y regulatoria es lo que ha impulsado a plantear este framework. 

c) 

Técnicas/Herramientas: Este framework ofrece un modelo arquitectónico y políticas; se implementa herramientas específicas para la gestión de identidad, para el control de la comunicación, para las políticas del código y el uso de herramientas SAST/DAST. Aparte de esto, también principios como: mínimo privilegio y microsegmentación para alinearse a estándares como NIST. 

d) 

Principal resultado: Entonces, este framework práctico proporciona un mapa detallado que conecta principios teóricos con la implementación práctica, una estructura de gobernanza integral y evaluable con los establecidos 7 dominios y 23 subcategorías, y la adaptación de Zero Trust al sector financiero.  

 

Resumen artículo 14: Secure Software development and testing: A model-based methodology 

a) 

Aporte: El artículo se centra en una metodología que integra la seguridad en el desarrollo de software, sobre todo en entornos DevOps/DevSecOps. La metodología busca cerrar la brecha entre el modelado de amenazas y la ejecución de pruebas de seguridad al integrar y automatizar ambos procesos del ciclo DevSecOps ​(Casola et al., 2024)​. 

b) 

Problema: Para este artículo se reconoció la falta de integración de la seguridad en proyectos y la gran dependencia de expertos en seguridad, lo cual resulta costoso y poco escalable. 

c) 

Técnicas/Herramientas: Esta metodología se sustenta en un ecosistema de herramientas y estándares para facilitar la seguridad automatizada, con modelado gráfico de componentes de la aplicación y para entornos de contenedores. Esta metodología se vincula con un Catálogo de Amenazas y la utilización de frameworks para generar planes de pruebas automáticas. 

d) 

Principal resultado: El resultado de esta metodología es vincular el modelado de amenazas con planes de pruebas específicos y ejecutable, reducir la dependencia de expertos con una guía para los desarrolladores, enfocarse principalmente en activos y riesgos. 

 

Resumen artículo 15: DLAP: A Deep Learning Augmented Large Language Model Prompting framework for software vulnerability detection 

a) 

Aporte: Este artículo ofrece modelos pre entrenados de Deep Learning para generar prompts de alta calidad que afinarían el LLM para una tarea específica, lograr un rendimiento cercano al fine-tuning (un enfoque para transferir el aprendizaje) con una fracción del costo computacional ​(Yang et al., 2025)​. 

b) 

Problema: El principal desafío es la baja capacidad de generalización de los modelos de Deep Learnig, el cual el rendimiento puede caer hasta un 73% al reutilizarlo en otro proyecto; el bajo rendimiento de LLMs en la detección de vulnerabilidades y el alto costo del fine-tuning. 

c) 

Técnicas/Herramientas: Para este framework se utiliza técnicas de Prompting, para encontrar ejemplos de código similares en el conjunto de entrenamiento. Además de modelos y herramientas Integradas: Modelos DL evaluados, LLMs utilizados, herramientas de Análisis Estático, técnica de Fine-tuning comparativa. 

d) 

Principal resultado: Este framework muestra que puede lograr un rendimiento en la detección de vulnerabilidades comparable al del fine-tuning sin tener que costear altos precios computacionales. También mejorar la eficiencia al combinar la alta generalización y capacidad de explicación de los LLMs. 

 

Resumen artículo 16: Unveiling Android security testing: A Comprehensive overview of techniques, challenges, and mitigating strategies 

a) 

Aporte: El artículo propone un framework de referencia integral para la evaluación de seguridad en Android. Establece un flujo de trabajo VAPT (Planificación, Escaneo, Explotación e Informe), clasifica vulnerabilidades específicas de Android: fallos de implementación, diseño y configuraciones incorrectas, y un mapeo de técnicas y herramientas según el análisis ​(Palutla et al., 2025)​. 

b) 

Problema: Los enfoques tradicionales de Evaluación de Vulnerabilidades y Pruebas de Penetración terminan siendo insuficientes para asegurar la seguridad del ecosistema. Esto es por problemas clave como la alta fragmentación del ecosistema, la naturaleza de código abierto y las amenazas específicas de Android: mal manejo de permisos, almacenamiento inseguro y el malware. 

c) 

Técnicas/Herramientas: El artículo propone sistematizar y comparar técnicas y herramientas ya existente. Para las técnicas de análisis: 

Análisis estático con herramientas como MobSF, QARK, AndroBugs, FlowDroid, APKTool, JADX. 

Análisis dinámico con herramientas como Drozer, Frida, Burp Suite, Xposed Framework. 

Análisis híbrido con herramientas como JAADAS, Quark Engine, DroidBox. 

Pruebas de penetración con herramientas como: Metasploit, Nmap, Nessus, Social-Engineer Toolkit (SET). 

d) 

Principal resultado: Entonces, el artículo resulta en una mejora de:  

Identificación de vulnerabilidades críticas en aplicaciones reales, específica de Android.  

Validación del enfoque híbrido, mejora la detección y reduce los falsos positivos al combinar los análisis estático y dinámico. 

Evaluación de herramientas, comparando su rendimiento. 

Recomendaciones prácticas para desarrolladores y evaluadores. 

 

Automatización inteligente y detección avanzada de vulnerabilidades Android 

 

Resumen artículo 17:  Assessing the security of inter-app communications in android through reinforcement learning 

a) 

Aporte: El articulo introduce RONIN, un sistema pionero que demuestra que es posible automatizar la verificación de vulnerabilidades en Android mediante inteligencia artificial, reduciendo falsos positivos y aumentando la eficiencia en el análisis de seguridad móvil. Su contribución principal es cerrar la brecha entre la detección teórica y la confirmación practica de vulnerabilidades ​(Romdhana et al., 2023)​.  

b) 

Problema: Las herramientas existentes detectan posibles vulnerabilidades, pero no pueden demostrar sin son explotables porque no simulan las interacciones del usuario ni los mensajes internos necesarios. Esto deja una brecha entre la detección teórica y la validación practica del riesgo real en las aplicaciones Android. 

c) 

Técnicas/Herramientas: RONIN integra tres etapas: La primera etapa es el análisis estático con SEBASTiAN para identificar fallas potenciales, el segundo es la instrumentación con Soot para registrar si las pruebas alcanzan el código vulnerable y el ultimo es Aprendizaje por refuerzo profundo (Soft Actor Critic) que, mediante el entorno de pruebas OpenAI Gym y la simulación de eventos GUI con ARES, aprende a generar los Intents correctos para explotar la falla.  

d) 

Principal resultado: RONIN logro explotar todas las vulnerabilidades de los conjuntos de prueba y en un análisis de 1 500 aplicaciones de Google Play, genero tres veces más exploits únicos (IDOS, XAS, FI) que la herramienta de referencia Letterbomb. Esto demuestra su capacidad para validar vulnerabilidades reales de forma automática y eficiente, aportando evidencia practica el campo de la seguridad móvil.   

 

Resumen artículo 18: A GUI-based Metamorphic Testing Technique for Detecting Authentication Vulnerabilities in Android Mobile Apps  

a) 

Aporte: El articulo propone una técnica de pruebas metamórficas aplicadas a la interfaz gráfica (GUI) para detectar vulnerabilidades en la autenticación de aplicaciones Android. Su principal aporte es trasladar las pruebas de seguridad al nivel de interacción del usuario, permitiendo verificar, durante el uso real de la aplicación, si se cumplen los comportamientos seguros esperados. De esta forma, las pruebas se vuelven más representativas y prácticas que los análisis de código tradicionales ​(Amalfitano et al., 2025)​.  

b) 

Problema: Las herramientas existentes se enfocan en el código o en la comunicación de red, pero no evalúan lo que ocurre en la pantalla mientas el usuario interactúa con la aplicación. Esta limitación genera el llamado “problema del oráculo” que consiste en la dificultad de saber si una falla detectada realmente pone en riesgo la seguridad. Por ello, muchas vulnerabilidades en la autenticación o en la gestión de sesiones no son detectadas antes del despliegue.  

c) 

Técnicas/Herramientas: El estudio plantea cinco reglas de comportamiento derivadas de estándares como OWASP y CWE, diseñadas para evaluar certificados, sesiones, transmisión segura y autenticación. Utiliza un entorno automatizado que graba las acciones del usuario, las reproduce de forma controlada, supervisa el tráfico de red y compara las respuestas visuales de la interfaz para identificar vulnerabilidades durante la ejecución.  

d) 

Principal resultado: Se analizaron 163 aplicaciones reales y se encontraron 159 vulnerabilidades. Más de cien de ellas presentaban al menos una falla. Los autores informaron los resultados a las empresas afectadas, nueve confirmaron los errores y veintiséis actualizaron sus aplicaciones. También observaron que las aplicaciones con más descargas o mejor calificación no necesariamente eran mas seguras.  

 

Resumen artículo 19: METFORD – Mutation tEsTing Frameworl fOR anDroid  

a) 

Aporte: El artículo presenta METFORD, un marco de pruebas por mutación para Android que soporte dos estrategias (tradicional y mutant schemata). Su contribución es reducir los costos de aplicar mutation testing en móviles al codificar múltiples mutantes en un solo proyecto y controlar su activación, además de ofrecer herramientas, scripts y datos abiertos para su uso y extensión, Valida que la estrategia propuesta mantiene el comportamiento de los mutantes y aporte métricas claras de ahorro (tiempo/espacio/ejecución) sobre aplicaciones reales ​(Vincenzi et al., 2025)​.  

b) 

Problema: El estudio identifica que el testing por mutación en Android enfrenta un problema de alto costo y baja eficiencia. Generar, compilar e instalar cada mutante por separado requiere gran cantidad de recursos de tiempo, espacio y procesamiento, lo que dificulta su aplicación en proyectos reales. Esta complejidad impide que las pruebas de mutación se usen ampliamente en el desarrollo móvil, reduciendo su impacto en la mejora de la calidad del software.  

c) 

Técnicas/Herramientas: METFORD implementa mutant schemata (todo los mutantes en un solo código con un comunicador para activarlos) y la estrategia tradicional (un proyecto por mutante). Emplea el compilador Kadabra (transformación Java con scripts en JavaScript) para aplicar 14 operadores (Android-específicos y generales) sobre proyectos Android, genera reportes en JSON con IDs consistentes. Define scripts de ejecución en emulador con control de tiempo (timeout), dos modos de corridas (“all-against-all” y “fast-fail”) y procedimientos para minimizar flakiness.  

d) 

Principal resultado: En seis aplicaciones open source con pruebas instrumentadas, la estrategia schemata: genera mutantes 8.5% más rápido que lo tradicional, requiere 99.78% menos espacio en disco y ejecuta los mutantes en promedio 6.45% más rápido. Se demostró equivalencia de comportamiento entre estrategias (las divergencias se debieron a flakiness de pruebas). Además, se reportan bajos mutation scores de las suites existentes, evidenciando margen de mejora en pruebas de UI en Android.  

 

Resumen artículo 20: Defendroid: Real-time Android code vulnerability detection via blockchain federated neural network with XAI  

a) 

Aporte: El articulo presenta una propuesta para detectar código con riesgos en Android a tiempo real dentro de Android Studio. Su aporte es adelantar la verificación de seguridad a las primeras fases del desarrollo y explicar en lenguaje comprensible porque una línea es problemática, sin exponer el código de la empresa. Además, promueve la colaboración entre equipos al compartir del modelo de forma segura ​(Senanayake et al., 2024)​.  

b) 

Problema: Las soluciones habituales llegan tarde (al final del ciclo), no explican el motivo de la alerta y no pueden aprovechar código privado para entrenar modelos por temas de confidencialidad. Esto limita la corrección temprana, genera desconfianza en los resultados y frena el aprendizaje colectivo entre organizaciones. 

c) 

Técnicas/Herramientas: Defendroid usa un modelo de aprendizaje automático entrenado con un conjunto de ejemplos de vulnerabilidades (LVDAndro). Para proteger la privacidad, adopta aprendizaje federado: cada equipo entrena localmente y solo comparte parámetros del modelo, no el código. Emplea un registro distribuido para aceptar únicamente versiones que demuestren mejora y usa técnicas de explicabilidad para resaltar palabras o fragmentos que justifican la alerta. Se entrega una API y un plugin para Android Studio con dos modos: revisión rápida del archivo completo y revisión detallada por línea. 

d) 

Principal resultado: El sistema muestra alto desempeño: alrededor de 96% de precisión y un F1 de 0.96 en pruebas de calificación, en el escenario colaborativo mantiene cifras similares. El plugin analiza una línea en aproximadamente 300 milisegundos y en pruebas comparativas supera herramientas conocidas. En evaluaciones con desarrolladores, la mayoría reportó satisfacción con la precisión, la velocidad y la utilidad de las explicaciones, Cubre diez categorías frecuentes de debilidades de seguridad en código Android.  

 

Resumen artículo 21: A survey on Android dynamic evasive malware: Taxonomy, countermeasures and open challenges 

a) 

Aporte: Este artículo ofrece taxonomía innovadora que depende del contexto, clasificando evasiones en tipos de entornos de análisis y condiciones de activación (trigger-condition). Análisis temporal de evolución de estrategias y migración de implementación de código. Revisión sistemática y comparativa de contramedidas en tres dominios: optimización de entornos de análisis, identificación de malware evasivo y exploración de comportamientos maliciosos, con insights técnicos, fortalezas, limitaciones y tendencias ​(D. Zhang et al., 2025)​. 

b) 

Problema: El artículo navega sobre los desafíos de ciberseguridad en malware evasivo dinámico para Android, que detecta entornos de análisis (emuladores, depuradores, herramientas de hooking) y altera su comportamiento para evadir detección, suprimiendo acciones maliciosas o entrando en estados dormidos. Esto genera trazas incompletas o engañosas, aumentando falsos negativos en análisis dinámico. 

c) 

Técnicas/Herramientas: Los autores usan metodologías de revisión sistemática de literatura: búsqueda basada en consultas en bases de datos como: Google Scholar, IEEE Xplore, ACM Digital Library, SpringLink y ScienceDirect, con palabras claves. Técnica de snowbailing para referencias adicionales. Los criterios de selección fueron: relevancia temática, venues de alto impacto, timelines. Análisis comparativo y taxonomía contextual. Las herramientas mencionadas fueron emuladores, hooking. Para contramedidas hardening, identificación de código evasivo, exploración UI. 

d) 

Principal resultado: La encuesta unifica estrategias de evasión en una taxonomía contextual, revelando evolución de técnicas. Comparación muestra que ninguna contramedida cubre todas las evasiones, identifica cinco desafíos claves que impiden detección y propone direcciones futuras como análisis cross-layer, XAI para evaluaciones IA y datasets especializados. 

 

Resumen artículo 22: Machine Learning for Android Malware Detection: Mission Accomplished? A Comprehensive Review of Open Challenges and Future Perspectives 

a) 

Aporte: El artículo realizó una revisión exhaustiva que identificó y describió cinco desafíos no resueltos en la detección del malware basada en Machine Learning, desde fallas metodologías hasta limitaciones de datasets, promoviendo direcciones futuras de investigación ​(Guerra-Manzanares, 2024)​. 

b) 

Problema: Desacreditando la percepción de que la detección de malware en Android mediante aprendizaje automático (Machine Learning) es un problema resuelto, a pesar de las altas métricas de rendimiento reportadas. Identifica cinco desafíos no resueltos que impiden soluciones efectivas a largo plazo: 

Escasez de datasets actualizados, equilibrados y de alta calidad, con problemas como datos obsoletos, duplicados, desbalanceados y con etiquetado incierto. 

Asunción errónea de consistencia en datos dinámicos a través de plataformas (inconsistencias en llamadas al sistema entre emuladores y dispositivos reales). 

Negligencia del concepto de drift, evolución del paisaje de amenaza, causando degradación del modelo. 

Exploración superficial de la seguridad de modelos, ataques adversarios como evasión y envenenamiento. 

Enfoque excesivo en rendimiento, ignorando compresión y explicabilidad del modelo. 

c) 

Técnicas/Herramientas: Revisión de literatura sistemática: búsqueda en Google Scholar y Scopus. Análisis relacional y cualitativo para identificar gaps. Tablas para síntesis: datasets, estudios dinámicos, drift, ataques adversarios. 

d) 

Principal resultado: La detección de malware Android no es un problema resuelto debido a cinco desafíos claves, respaldados por análisis de literatura. Estudios muestran caídas en rendimiento por drift, inconsistencias dinámicas, vulnerabilidades adversarias y falta de explicabilidad. Recomienda datasets representativos, manejo de drift, seguridad contra envenenamiento/deriva adversarial y XAI para insights, acercando el problema a resolverse. 

 

Resumen artículo 23: Towards a fair comparison and realistic evaluation framework of android malware detectors based on static analysis and machine learning 

a) 

Aporte: Este artículo realiza identificación de cinco factores que afectan negativamente la precisión de detectores, argumentando su inclusión para evaluaciones realistas; análisis de 10 detectores state-of-art bajo un marco común, demostrando rendimientos optimistas debido a fallas de diseño/evaluación; destacar problemas de reproducibilidad y liberación pública de código/datasets en GitLab para facilitar comparaciones; y discusión de líneas futuras de investigación para abordar fallas, incluyendo marcos realistas, etiquetado robusto, manejo de desbalanceo, diseños resistentes a evasión y ML adaptativo para datos evolutivos ​(Molina-Coronado et al., 2023)​. 

b) 

Problema: Falta de reproducibilidad y marcos de evaluación estándar en detectores de malware Android basados en Machine Learning y análisis estático, lo que dificulta comparaciones justas y genera evaluaciones optimistas. Identifica cinco factores clave que afectan el rendimiento y a menudo se ignoran: 

Presencia de muestras duplicadas en datasets, causando sesgos en entrenamiento y métricas infladas. 

Atribución de etiquetas (goodwares/greywares/malwares) inconsistente, con umbrales variables en VirusTotal Detections (VTD) y cambios temporales en etiquetas. 

Desbalanceo de clases (más goodwares que malwares), sesgando modelos hacia la clase mayoritaria. 

Técnicas de evasión en aplicaciones, reduciendo tasas de detección sin alterar funcionalidad. 

Evolución temporal de aplicaciones (distribuciones no estacionarias), degradando modelos en datos nuevos con aumento de falsos positivos/negativos. Estos derivan de datasets obsoletos/incompletos. 

c) 

Técnicas/Herramientas: Reimplementación en Python de 8/10 detectores seleccionados. Análisis estático para extracción de features APKs; datasets divididos en entrenamiento/pruebas con 5-folds cross-validation (consciente del tiempo para evolución) y grid search para hiperparámetros. Experimentos comparativos en escenarios baseline (optimista) y específicos por factor. 

d) 

Principal resultado: En escenarios baseline optimistas, se reproducen rendimientos altos, pero factores realistas causan caídas sustanciales: duplicados de mejora generalizada, pero reduce métricas en test filtrados; umbrales VDT altos facilitan detección, pero greywares muestran incertidumbres. Concluye en que detectores se evalúan optimistamente, con los factores reales haciendo rendimientos irrelevantes para despliegue; ML clásico insuficiente; urge marcos realistas; libera recursos para progreso. 

 

Resumen artículo 24: AndroMD: An Android malware detection framework based on source code analysis and permission scanning 

a) 

Aporte: Pipeline automático para construir datasets de más de 600 000 APKs únicos, extrayendo features estáticas, generando KeyCount, ZeroOne, MNF. Técnica iterativa de selección óptima de features basada en ranking/importancia y feedback de esemble, reduciendo dimensionalidad manteniendo precisión/semántica ​(Prasad et al., 2025)​. 

b) 

Problema: Crecimiento rápido de aplicaciones Android en móviles e IoT aumenta la superficie de ataque. Adversarios usan aplicaciones e ingeniería social para comprometer la seguridad/privacidad. Desafíos en detección de malware sofisticado, limitaciones de datasets existentes, falta de selección óptima de features y modelos escalables para detección estática a gran escala. 

c) 

Técnicas/Herramientas: Combina análisis estático del código con una evaluación de permisos para detectar patrones sospechosos. Utiliza técnicas de aprendizaje automático para clasificar las aplicaciones según su nivel de riesgo y genera reportes visuales de las características que más contribuyen a la detección. También emplea una arquitectura modular que facilita la incorporación de nuevos modelos y datasets, permitiendo escalar el sistema a cientos de miles de aplicaciones. 

d) 

Principal resultado: El marco logró analizar más de 600 000 aplicaciones de Android y construir tres conjuntos de datos que mejoran la comparación entre modelos. Los resultados muestran una alta precisión la identificación de malware, con un rendimiento competitivo frente a detectores existente. Su diseño abierto y reproducible permite replicar los experimentos y fortalecer la confianza en la investigación sobre seguridad móvil. 

 

2.2.4 Modelos de aprendizaje automático y detección inteligente de malware en Android 

Resumen artículo 25: ActDroid: An active learning framework for Android Malware  

a) 

Aporte: ActDroid introduce un novedoso marco de aprendizaje activo capaz de reducir drásticamente la dependencia de grandes conjuntos de datos etiquetados para la detección de malware Android. Su aporte principal es demostrar que con solo el 30% de los datos etiquetados, combinados con datos no etiquetados, se puede alcanzar a una precisión superior al 96.3%. Este enfoque contribuye significativamente a la eficiencia en escenarios donde el etiquetado manual es costoso, permitiendo mantener sistemas actualizados con menos recursos humanos y computacionales ​(Muzaffar et al., 2025)​.  

b) 

Problema: El estudio responde a la dificultad persistente en los sistemas tradicionales de detección de malware en Android: la dependencia intensiva de grandes volúmenes de datos etiquetados y el pobre desempeño ante amenazas nuevas no representadas en el conjunto de entrenamiento. Esto se agrava por el carácter cambiante de las amenazas móviles y por el hecho de que el etiquetado manual requiere esfuerzo experto y no escalable. Como ejemplo, el conjunto de datos Drebin incluyó más de 5,560 aplicaciones maliciosas, lo que evidencia la magnitud del problema de clasificación precisa frente a nuevas variantes.  

c) 

Técnicas/Herramientas: ActDroid aplica técnicas avanzadas de aprendizaje activo con tres estrategias: Entropy Sampling, Least Confidence y Margin Sampling, integradas a clasificadores como XGBoost, Random Forest y SVM. Para la extracción de características estáticas se analiza el archivo AndroidManifest.xml y el código fuente descompilado, generando vectores de características binarios. El entorno de prueba incluyo uso del conjunto Drebin como benchmark, empleando python 3.10, librerías como: scikit-learn, XGBoost y pandas, utilizando validación cruzada 10-fold para robustecer los resultados.  

d) 

Principal resultado: Los resultados experimentales muestran que ActDroid alcanza una precisión de 96.3% usando solo el 30% de datos etiquetados, superando en 2-3% a los clasificadores tradicionales que usan el 100% de los datos etiquetados. Además, se reporta una mejora sustancial en recall (95.9%) y F1-score (95.7%), al combinar datos no etiquetados con estrategias activas. El framework logra reducir el costo de etiquetado en un 70%, manteniendo alta eficacia en la detección, lo cual valida su aplicabilidad para entornos móviles donde la evolución constante del malware exige modelos adaptativos y eficientes.  

 

Resumen artículo 26: GSEDroid: GNN-based Android malware detection framework using lightweight semantic embedding  

a) 

Aporte: GSEDroid propone un enfoque innovador para detectar malware en Android al utilizar representaciones semánticas ligeras junto con una red neuronal basada en grafos (NN). Aporta una forma eficiente de modelar la semántica del código sin necesidad de características manuales extensas, lo que permite mejorar la precisión del sistema incluso frente a técnicas de ofuscación. Este marco logra una compresión del 42% en los vectores de características respecto a métodos anteriores, facilitando su integración en entornos de recursos limitados sin comprometes el desempeño ​(Gu et al., 2024)​.  

b) 

Problema: El articulo aborda el problema critico de la ineficiencia de los métodos tradicionales de detección de malware en Android, los cuales suelen depender de características manuales y no logran identificar correctamente amenazas cuando los atacantes aplican técnicas de camuflaje u ofuscación. Además, destaca que el análisis semántico profundo es escaso en los modelos existentes, lo que debilita su capacidad de generalización. Como contexto, se menciona que analizaron más de 10, 000 aplicaciones de AndroZoo, evidenciando limitaciones prácticas de los enfoques actuales frente a nuevas variantes de malware.  

c) 

Técnicas/Herramientas: Para construir GSEDroid, se utiliza un grafo de llamadas entre clases (Class Call Graph - CCG) como base para generar embedding semánticos ligeros que preservan entre métodos y clases. Luego, se aplican diferentes variantes de redes neuronales graficas, como GCN, GAT y DGCNN, para extraer patrones discriminativos. La implementación fue desarrollada con PyTorch Geometric y las pruebas se ejecutaron sobre un dataset de 15, 000 APKs de AndroiZoo, con métricas como Accuracy, Precision, Recall y F1-Score, que permiten una evaluación rigurosa de desempeño.  

d) 

Principal resultado: Los resultados experimentales muestran que GSEDroid alcanza una precisión del 97.32% y un F1-Score de 97.40%, superando ampliamente a los modelos comparativos como GCN (94.28%) y GAT (95.14%). Además, el sistema reduce el tiempo de entrenamiento en 18.7% y el tamaño de los vectores en un 42%, lo que valida su efectividad tanto en precisión como en eficiencia computacional. Estos indicadores posicionan a GSEDroid como una solución viable para escenarios donde se requiere detección de malware ágil y confiable en dispositivos Android.  

 

Resumen artículo 27: MCGDroid: An Android malware classification method based on multi-feature class-call graph characterization  

a) 

Aporte: El estudio presenta MCGDroid, una propuesta metodológica para la clasificación de malware Android Basada en grafos de llamadas entre clases enriquecidos con múltiples atributos semánticos. A diferencia de trabajos anteriores, este enfoque integra secuencias de opcodes y llamadas a APIs sensibles en la estructura del grafo, lo cual permite capturar tanto la semántica como la estructura global del comportamiento malicioso. Esta estrategia representa un avance sustancial al reducir la complejidad estructural sin sacrificar precisión, logrando un equilibro entre rendimiento y expresividad para entornos Android ​(He et al., 2026)​.  

b) 

Problema: Las técnicas convencionales de detección de malware en Android enfrentan dos limitaciones clave: la falta de análisis semántico profundo y el alto de costo computacional. Métodos que usan permisos, APIs o firmas estáticas resultan frágiles frente a técnicas de ofuscación, mientras que aquellos que emplean grafos de flujo de control o datos que generan estructuras excesivamente grandes que consumen muchos recursos. En 2024, según Kaspersky, se detectaron 33.3 millones de ataques maliciosos en Android, siendo el adware el 35% del total, lo que subraya la necesidad urgente de sistemas eficientes y robustos frente a amenazas evasivas.  

c) 

Técnicas/Herramientas: MCGDroid realiza análisis estático con Androgurad 3.3.5, construye grados dirigidos (CCG) a partir de código smali y codifica nodos usando secuencias normalizadas de opcodes y APIs sensibles. Emplea un modelo de red neuronal convolucional sobre grafos llamados CT-CGN, conformado por 3 bloques T-GCN, capas de poolin y dos capas densas para clasificación. La arquitectura se entrenó con el dataset CICMalDroid-2020 (16,615 apps, de las cuales 4037 son benignas y 12,578 maliciosas), usando PyTorch, optimización con Adam y activación ReLU. El valor optimo de secuencia fue d = 32, tras 7 experimentos de prueba.  

d) 

Principal resultado: MCGDroid logro una precisión del 98.92% en detección y 97,02% en clasificación, con F1-Score de 98.54% y 96.65% respectivamente. Ante muestras ofuscadas (usando 8 técnicas distintas), el rendimiento se mantuvo alto: 93.12% en detección y 86.26% en clasificación, con solo 5.8% de caída. El sistema clasifico cada app en 0.003 s en GPU y 0.016 s en CPU y supero a métodos como Drebin, DexRay y FCG-MDet en todos los indicadores clave, validando así su superioridad tanto en efectividad como en resistencia antes técnicas de evasion.  

 

Resumen artículo 28: DroidTTP: Mappng android applications with TTP for Cyber Threat Intelligence 

a) 

Aporte: El trabajo introduce DroidTTP, el primer enfoque sistemático que vincula aplicaciones Android con técnicas, tácticas y procedimientos (TTPs) del marco MITRE ATT&CK para generar inteligencia de amenazas cibernéticas (CTI) más precisa y automatizable. Este mapeo estructurado permite crear indicadores tácticos avanzados que van más allá de firma tradicionales, facilitando la detección proactiva de amenazas emergentes especialmente aquellas ocultas en comportamiento legítimos de apps ​(R. Arikkat et al., 2025)​. 

b) 

Problema: La detección de malware en Android presenta un desfase significativo entre los mecanismos actuales de análisis y el perfil dinámico de las amenazas. Los sistemas existentes se centran en indicadores de compromiso (IoCs), que son volátiles y fácilmente evadibles. El articulo enfatiza que más del 70% de las muestras maliciosas analizadas utilizan APIs legitimas para camuflar su actividad, lo cual complica enormemente su clasificación sin una semántica táctica.  

c) 

Técnicas/Herramientas: DroidTTP se basa en análisis estático con FlowDroid y Androguard, combinados con un modelo de extracción semántica que traduce patrones de comportamiento en TTPs usando un sistema de reglas basadas en JAPE. La base de entrenamiento incluyo 120, 000 funciones extraídas de 5, 000 apps, procesadas para mapear acciones con entradas especificas con el marco ATT&CK Mobile. Para validación, se usó un entorno hibrido con muestras de CICMalDroid, etiquetas de expertos humanos y registros de ataques conocidos.  

d) 

Principal resultado: El modelo logro una precisión de mapeo del 94.28% en la detección de TTPs, con una cobertura promedio de 2.5 TTPs por app maliciosa y solo 0.4 en apps benignas, demostrando una clara discriminación táctica. El sistema redujo los falsos positivos en un 23% frente a métodos clásicos basados en firmas y elevo en un 18.6% la capacidad de detección en escenarios realistas según métricas ROC-AUC, consolidándose como una herramienta eficaz para la CTI automatizada en dispositivos móviles.  

 

Resumen artículo 29: MPDroid: A multimodal pre-training Android malware detection method with static Dynamic features 

a) 

Aporte: El estudio propone un paradigma de aprendizaje multimodal que fusiona características estáticas y dinámicas para mitigar el sesgo unimodal, incorporando alineación de modalidades y fusión a nivel de modelo, lo que permite inferencia eficiente en una sola modalidad y reduce el tiempo de entrenamiento en tareas downstream ​(S. Zhang et al., 2025)​.  

b) 

Problema: Los métodos de detección de malware en Android enfrentan limitaciones en análisis estáticos vulnerables a ofuscación con precisión comprometidas, y dinámicos que consumen recursos intensivos, con ataques móviles alcanzando 33.8 millones en 2023 y un incremento del 50% respecto al año anterior según informe de Kaspersky. 

c) 

Técnicas/Herramientas: Se utiliza un grafo de llamadas a funciones para características estáticas y un grafo de APIs del sistema para dinámicas, procesadas con redes convolucionales de grafos y atención propia, junto con pre-entrenamiento multimodal y fusión a nivel de modelo para manejar sesgos en datasets grandes. 

d) 

Principal resultado:  MPDroid alcanza una precisión promedio de 98.3% y un F1-score del 97.6% con un tiempo de detección inferior a 7.39 segundos, superando métodos existentes como DroidDetectMW y DL-AMDet en rendimiento general. 

 

Resumen artículo 30: A novel image based appoach for mobile Android malware detection and classification 

a) 

Aporte: La propuesta presenta un sistema basado en imágenes para detectar malware en Android y clasificar familias, abordando duplicados y desequilibrios en datasets mediante limpieza de datos y aumento con aplicaciones reales, mejorando la aplicabilidad práctica en seguridad móvil ​(Yapici, 2025)​. 

b) 

Problema: El incremento de ataques a Android, con 33,790,599 detecciones de malware, adware y software riesgoso en 2023 según Kaspersky, genera resultados sesgados en estudios previos debido a datos duplicados y desequilibrados entre clases, lo que afecta la fiabilidad de las clasificaciones. 

c) 

Técnicas/Herramientas: Se convierten archivos de bytecode Dalvik en imágenes RGB y grayscale, aplicando redes neuronales convolucionales para extracción de características, con aumento de datos real y remoción de duplicados en datasets como AndroZoo, Drebin y AMD para evitar sobreajuste. 

d) 

Principal resultado: El sistema logra una precisión promedio de 98.7%, recall de 98.6% y F1-score de 98.6%, superando estudios previos en los mismos datasets y demostrando que la limpieza de datos mejora el rendimiento significativamente. 

 

Resumen artículo 31: Android traffic malware analysis and detection using ensemble classifier 

a) 

Aporte: La técnica STAR introduce un enfoque sistemático para lograr la precisión en la identificación y clasificación de malware en Android, integrando recopilación de datos diversa y votación mayoritaria para robustecer la seguridad de aplicaciones móviles contra amenazas evolutivas ​(Mohanraj & Sivasankari, 2024)​. 

b) 

Problema: El crecimiento exponencial de usuarios de Android, con 3.718 millones descargando apps de Google Play en 2023, eleva las vulnerabilidades, donde el malware afecta la privacidad y seguridad, con pronósticos de 7.4 billones de usuarios para noviembre 2024 incrementando los riesgos cibernéticos. 

c) 

Técnicas/Herramientas: Se emplea análisis de componentes principales para extracción de características, optimización de mariposas para selección, y clasificadores ensemble como Bagging, AdaBoost, combinados con votación mayoritaria variados para clasificar tráfico de Android. 

d) 

Principal resultado: STAR supera a ERBE, De-LADY y MSFDroid con tasas de detección 4.34%, 1.41% y 2.52% superiores respectivamente, demostrando eficiencia computacional y capacidad para diferenciar actividades benignas de maliciosas con precisión elevada. 

 

Resumen artículo 32: Comprehensive benchmarking of knowledge graph embeddings methods for Android malware detection 

a) 

Aporte: Esta investigación introduce una pipeline de representación de datos basada en grafos de conocimiento para la detección de malware en Android, organizando características estáticas extraídas de APKs en una estructura grafica interpretable, lo que permite una integración potencial con fuentes externas de inteligencia de amenazas y soporta la evolución continua del pipeline de detección con menor complejidad computacional comparada con enfoques de aprendizaje ​(Kincl et al., 2025)​. 

b) 

Problema: La popularidad del sistema operativo Android, con más del 70% de la cuota de mercado de dispositivos móviles en 2024, lo convierte en un objetivo principal para ataques de malware, y casi el 50% de los programas antivirus gratuitos para Android son ineficaces en la detección de aplicaciones maliciosas. 

c) 

Técnicas/Herramientas:  Se evalúan cuatro funciones de puntuación de embeddings de grafos de conocimiento, como TransE, DistMult, ComplEx y HoIE, a través de seis dimensiones de vectores desde 5 hasta 100, utilizando clasificadores simples como SVM y Random Forest, junto con representaciones basadas en bag-of-words y reducción PCA para comparar el rendimiento en datasets de malware. 

d) 

Principal resultado: Los embeddings HoIE logran una precisión comparable o superior con dimensionalidad reducida, superando al modelo bag-of.words simple y manteniéndose competitivo con enfoques de vanguardia, con una precisión de detección alta que valida el uso de representaciones semánticas ricas en entornos con recursos limitados. 

2.2.5 Detección de Malware Android con Machine Learning y Técnicas Avanzadas 

Resumen artículo 33: A ligtweight deep learning-based android malware detection framework 

a) 

Aporte: El estudio introduce MCADS, un sistema ligero de detección de malware Android con arquitectura de dos capas. La primera capa usa una red MLP mejorada que analiza únicamente el archivo AndroidManifest.xml, identificado correctamente el 99.73% de aplicaciones con un umbral de confianza de 0.9. La segunda capa propone ShuffleNetV2-ECA, una variante de red convolucional que integra módulos de atención eficiente (ECA) para capturar características globales de imágenes. DEX, logrando un modelo compacto de solo 20.41 MB con 5.3 millones de parámetros, significativamente más pequeño que alternativas como EfficentNet-B4 que ocupa más de 60 MB ​(Ma et al., 2024)​.  

b) 

Problema: Android enfrenta amenazas crecientes con más de 196,476 nuevos troyanos bancarios detectados en 2022. Los sistemas actuales de detección basados en aprendizaje profundo son demasiado complejos para dispositivos móviles. Modelo como EfficentNet-B4 requieren 17.5 millones de parámetros y archivos de más de 60 MB, mientras que métodos como DeepRefiner necesitan procesos complicados con vocabularios de bytecode y modelos Skip-Gram. Las técnicas de ofuscación dificultan el análisis estático tradicional y con más de 2.6 millones de aplicaciones en Google Play, la detección manual es imposible.  

c) 

Técnicas/Herramientas:  En framework emplea el algoritmo Dex2Image que convierte archivos DEX a formato RGB tomando tres números hexadecimales como parámetros de color, excluyendo la sección “data” para reducir información redundante. ShuffleNetV2-ECA incorpora módulos de atención que usan convolución 1D de kernel adaptativo. El entrenamiento uso optimizador Adam con tasa de aprendizaje 0.00001, ejecutando durante 60 épocas para CNN y 15 para MLP, sobre un dataset de 4,346 aplicaciones: 3, 440 para entrenamiento y 906 para pruebas, recopiladas de Google Play (1,620 benignas) y VirusShare (2,726 maliciosas), validas con VirusTotal.  

d) 

Principal resultado: De 906 aplicaciones de prueba, proceso 731 en la primera capa con 99.73% de precisión, enviando solo 175 a la segunda capa que logro 95.04% de accuracy con valor AUC de 0.99. El entrenamiento promedio fue 12.76 segundos por época, con tamaño total de 30.43 MB y 7.9 millones de parámetros, mostrando mejor balance eficiencia-rendimiento que EfficientNet-B4 (25.98s, 66.96MB, 17.5 M parametros) y Drebin (6.41s, pero 14 horas de extracción de características).  

 

Resumen artículo 34: The revolution and visión of explainable AI for Android malware detection and protection 

a) 

Aporte: La investigación presenta un enfoque de Inteligencia Artificial Explicable (XAI) para entender cómo funcionan los modelos de detección de malware Android. Utiliza las herramientas SHAP y LIME para mostrar visualmente que características son más importantes en la detección. Los resultados muestran que en el dataset CIC-InvesAndMal2019, la característica Feature 178 fue la más relevante para identificar malware, mientras que Feature 8 tuvo menor impacto, permitiendo a los expertos comprender mejor las decisiones de los algoritmos en lugar de trabajar con “cajas negras” ​(Ullah et al., 2024)​.  

b) 

Problema: Los sistemas actuales de detección de malware Android muestran resultados engañosos en ambientes controlados que no funcionan igual en situaciones reales. El estudio encontró que los modelos alcanzan tasas de precisión 96.11%, 90.24% y 99.48% en tres datasets diferentes (CIC-AAGM2017, CIC AndMal2017, CIC-InvesAndMal2019), pero estos resultados están inflados porque los clasificadores aprenden diferencias temporales entre archivos maliciosos y seguros en lugar de identificar comportamientos verdaderamente peligrosos, limitando su efectividad práctica.  

c) 

Técnicas/Herramientas:  Se utilizo un modelo hibrido CNN-LSTM entrenando con cuatro datasets públicos que incluyen categorías de malware como Adware, Banking, Ransomware, SMS malware, Scareware y Riskware. El análisis XAI genero visualizaciones de importación de características, efectos combinados e interacciones entre variables. Los experimentos se realizaron con procesador AMD Ryzen 5 3600, 128 Gb de RAM, GPU Nvidia GeForce RTX 3060Ti, utilizando Python 3.8.5 y Sci-Kit learn 0.24.1 durante entrenamiento de 50 épocas. 

d) 

Principal resultado: El modelo CNN-LSTM alcanzo 99.48% de precisión en el dataset CIC-InvesAndMal2019, pero el análisis XAI revelo que este alto rendimiento se debe a patrones temporales en los datos y no a verdadera comprensión de comportamiento maliciosos. Las visualizaciones mostraron que Features 4 y 2 contribuyen activamente a detectar malware, mientras Features 12 y 18 identifican aplicaciones seguras. Este hallazgo demuestra que la alta precisión en laboratorio no garantiza efectividad real, señalando la necesidad de cambiar el enfoque desde buscar solo exactitud hacia desarrollar sistemas confiables y aplicables.  

 

Resumen artículo 35: SeGDroid: An Android malware detection method based on sensitive function call graph learning 

a) 

Aporte: SeGDroid propone un método de detección de malware Android mediante aprendizaje de grafos llamadas sensibles (sensitive FCG). Introduce un algoritmo de poda que preserva únicamente las 21,986 APIs sensibles de PScout y sus contextos, eliminando nodos irrelevantes. Implementa representación semántica con modelos API2vec y opcode2vec usando word2vec skip-gram, ponderando vectores con métricas de centralidad (degree centrality) para capturar conocimiento semántico y estructura topológica del grafo ​(Z. Liu et al., 2024)​.  

b) 

Problema: El malware Android evade detección mediante ofuscación. Los métodos basados en FCG presentan limitaciones: grafos con hasta 250,000 nodos en aplicaciones benignas (ratio de desbalance 10.3), técnicas previas solo consideran ocurrencia de APIs/opcodes sin semántica y nombres de funciones autodefinidas son fácilmente ofuscables. Además, no existían mecanismos de explicabilidad para modelos FCG que permitieran trazar comportamientos maliciosos específicos.  

c) 

Técnicas/Herramientas:  Emplea GrapghSAGE con dos capas convolucionales (64 y 32 nodos), learning rate 0.001, optimizador Adam y 100 épocas. Usa Androguard sobre datasets CICMal2020 (16,595 aplicaciones en 5 categorías) y MalRadar (3,935 muestras de 15 familias). Aplica umbral A=8,000 nodos para poda de grafos y modelo skip-gram de word2vec para embeddings contextuales de APIs y secuencias opcode.  

d) 

Principal resultado: Alcanzo F-score de 98% en detección binaria (CICMal2020) y 96% en clasificación de familias (MalRadar), superando GraphSAGE-Occ (90.49%) en 7.88 puntos. La poda redujo nodos promedio de 46,795 a 18,315, disminuyendo ratio de desbalance de 10.3 a 4.2. El método de explicabilidad identifico correctamente SmsManager.sendTextMessage y TelephonyManager como nodos de mayor importancia en malware SMS.  

 

Resumen artículo 36: Enhancing android malware detection explainability through function call graph APIs 

a) 

Aporte: Propone un enfoque explicable para detectar malware. Android extrayendo únicamente APIs críticas del Function Call Graph (FCG). Selecciona APIs de 11 paquetes de Android sensibles (telephony, net, accounts, location, media) que requieren permisos especiales de ejecución. Utiliza TF-IDF para elegir las 20 APIs más relevantes por aplicación y Word2Vec para generar embeddings de 25 dimensiones. Implementa SHAP para explicabilidad, permitiendo identificar directamente que APIs críticas se correlacionan con comportamiento maliciosos específicos de cada familia de malware, ofreciendo explicaciones comprensibles sin necesidad de analizar código bytecode ​(Soi et al., 2024)​. 

b) 

Problema: Los sistemas actuales de detección emplean conjuntos de características inflados (tamaños de aplicaciones, permisos genéricos, recursos del APK) que no presentan claramente funcionalidades maliciosas. La diversidad entre familias de malware (banking, ransomware, spyware) genera extracción másica de features irrelevantes que confunden al modelo. Las explicaciones visuales existentes mediante heatmaps requieren que analistas examinen manualmente el código DEX resaltado, proceso complejo y poco claro para determinar relevancia real de las secciones identificadas como críticas por el clasificador.  

c) 

Técnicas/Herramientas:  Utiliza Androguard para extracción estática del FCG evitando ejecución de aplicaciones. Dataset de 48,372 APKs (21, 459 benignos, 26,913 maliciosos de 432 familias) desde CICMal2020 y muestras adicionales CICAndMal2017. Implementan CNN con capas Conv1D, Dropout (0.2), MaxPooling y Dense, entrenada con Adam optimizar durante 8 épocas con batch de 20 muestras. Aplica SHAP como modelo surrogate que calcule relevancia de cada API mediante suma sobre matriz 20x25, generando scores de importancia para explicaciones locales (muestra individual) u globales (familias completas).  

d) 

Principal resultado: Obtuvo 87% de accuracy y F1-Score de 87% en validación cruzada. Identifico concept driftt significativo en 2016 cuando Android Nougat introdujo OpenJDK, causando caída de rendimiento en muestras posteriores. SHAP identifico correctamente APIs maliciosas: lockNow() y resetPassword() en ransomware LockerPin, getMacAddress() y sendTextMessage() en spyware (valores SHAP de 0.085 y 0.073). Las explicaciones mostraron correlación directa entre APIs sensibles y funcionalidades maliciosas específicas, permitiendo identificar automáticamente comportamientos característicos por familia de malware sin análisis manual de código.  

 

Resumen artículo 37: WHGDroid: Effective Android malware detection based on weighted heterogeneous graph 

a) 

Aporte: El marco WHGDroid introduce una arquitectura de modelado de aplicaciones Android mediante grafos heterogéneos ponderados, incorporando relaciones semánticas implícitas entre entidades para una detección más robusta, permitiendo la agregación de vecinos guiada por similitud y atención en metapaths para embeddings numéricos que capturan conexiones de alto nivel ​(Huang et al., 2023)​. 

b) 

Problema: El malware en Android compromete la seguridad de usuarios al evolucionar rápidamente con técnicas como confusión y encriptación, afectando al 75% de smartphones en 2019 desde el 4% en 2009, donde detectores tradicionales pierden efectividad al ignorar asociaciones inter-aplicaciones y enfocarse solo en características intra-app. 

c) 

Técnicas/Herramientas: Se extraen entidades como AndroGuard, se construye un WHG con pesos calculados por frecuencias diferenciales y factor malicioso, se definen metapaths como U-A-U para derivar grafos homogéneos, y se aplica GraphSAGE con agregación inductiva y MLP en datasets de AMD y Androzoo.  

d) 

Principal resultado: WHGDroid logra 98.71% de precisión en AMD con 24,650 muestras de 71 familias y 97.86% en conjunto mixto de 39,400 muestras de 2015-2018, superando a GDroid en recall por 2.2% en evolución y a MaMaDroid en accuracy por más del 39% en zero-day. 

 

Resumen artículo 38: Detection of Evasive Android Malware Using EigenGVN 

a) 

Aporte: Esta investigación presenta un mecanismo innovador basado en grafos de llamadas al sistema que captura subgrafos maliciosos invariantes a evasiones, representándolos como señales gráficas para una detección integral, destacando su novedad al abordar simultáneamente múltiples tipos de amenazas con una sola arquitectura ​(John et al., 2024a)​. 

b) 

Problema: El incremento de malware en Android, con 1,245,894 instalaciones maliciosas en Google Play Store durante 2021 según Kaspersky, se agrava por técnicas como ofuscación y reempaquetado que crean muestras de mimetismo adversarial, generando altas tasas de falsos positivos en detectores existentes al imitar distribuciones benignas. 

c) 

Técnicas/Herramientas: Se extraen secuencias con Monkeyrunner y Strace en emuladores ARM v8, construyendo grafos dirigidos con NetworkX, aplicando clustering espectral en EigenGCN para particionar en subgrafos, y computando centralidades como Betweenness, PageRank, Closeness y Katz como características para transformada de Fourier gráfica.  

d) 

Principal resultado: EigenGCN alcanza accuracies de 98.7% en 2230 muestras de Drebin para malware común, 97.3% en 800 de AndroZoo para ofuscado, 97.8% eb 1100 reempaquetadas en AndroZoo y MalGenome, y 90% en 700 de mimetismo, con FPR de 0.014 en general superando baselines. 

 

Resumen artículo 39: Malware detection for mobile computing using secure and privacy-preserving machine learning approaches: A comprehensive survey 

a) 

Aporte: Esta encuesta ofrece una evaluación detallada de la integración de aprendizaje federado en la detección de malware móvil, proponiendo un marco que aborda heterogeneidad de datos y modelos, junto con mecanismos para superar desafíos en sistemas Android e iOS, fomentando avances en estrategias colaborativas seguras ​(Nawshin et al., 2024)​. 

b) 

Problema: La proliferación de malware en dispositivos móviles, con ataques como ransomware causando pérdidas financieras de hasta 10.5 billones de dólares estimados para 2025, se intensifica por la exposición de datos sensibles en datasets de entrenamiento grandes, donde solo el 0.5% de aplicaciones en Google Play son maliciosas, pero afectan a millones de usuarios. 

c) 

Técnicas/Herramientas:  Se analizan enfoques como encriptación homomórfica para sub-cómputos seguros, k-anonimidad para anonimato de datos, y federated learning con actualizaciones personalizadas en nodos Edge, aplicados en análisis estático con extracción de características invariantes a ofuscación usando herramientas como AndroGuard en datasets de 15,036 muestras. 

d) 

Principal resultado: Los métodos híbridos con FL alcanzan 98.57% de precisión en Drebin y 97.90% en AndroMD con 3,547 muestras, superando clasificadores base en 16% de F1-score, y reducen vulnerabilidades a ataques zero-day al preservar privacidad sin compartir datos crudos. 

 

Resumen artículo 40: MobiPCR: Efficient, accurate, and strict ML-based mobile malware detection 

a) 

Aporte: El sistema MobiPCR introduce una arquitectura hibrida de nube y Edge que integra un modelo de aprendizaje automático liviano para identificar amenazas en aplicaciones móviles, mejorando la usabilidad práctica al automatizar el proceso sin intervenciones adicionales del usuario y soportando evoluciones continuas contra variantes emergentes ​(C. Liu et al., 2023)​. 

b) 

Problema: La prevalencia de malware en dispositivos móviles, con estimaciones Cisco indicando dominancia en la era 5G y 6G, expone a usuarios a riesgos como robo de datos desde fuentes web no verificadas, donde Android carece de herramientas integradas para detección previa, resultando en compromisos de seguridad en regiones con acceso limitado a tiendas oficiales. 

c) 

Técnicas/Herramientas:  Se utiliza Installer Hooker en LineageOS 13 para interceptar instalaciones, extrayendo características estáticas como permisos y APIs con AndroGuard, aplicando selección mediante InfoGain y Correlation-based Feature Selection, y ensemble dinámico con DES-KNN sobre clasificadores base como J48 y Random Forest en datasets de Drebin y AndroZoo. 

d) 

Principal resultado: MobiPCR logra 98.9% de precisión y 0.989 en F-measure en 10,000 muestras, superando a Avast Mobile Security en 15% de efectividad contra familias como FakeInstaller y DroidKungFu, con tiempos de detección de 2.5 segundos promedio y consumo de recursos mínimo en entornos Edge. 

 

Conclusiones comparadas por categoría  

 

Conclusiones comparadas del Diagnóstico de vulnerabilidades y evaluación de riesgos en entornos Android y iOS 

Mientras que ​Koman & Janiszewski (2025)​ se ocupan de evaluar herramientas DAST existentes mediante métricas comparativas, ​El-Zawawy & Hamdy (2025)​ desarrollan un método completamente nuevo para detectar escalamientos de privilegios de orden n en Android. Por otro lado, mientras que ​Lazarov et al. (2025)​ proponen una plataforma integral que combina pruebas manuales y automatizadas, ​Samhi & Bartel (2022)​ se enfocan específicamente en validar la actividad de técnicas existentes de detección de bombas lógicas. 

 

En terminos de alcance, mientras que algunos estudios abordan vulnerabilidades específicas del ecosistema Android ​(El-Zawawy & Hamdy, 2025; Samhi & Bartel, 2022; Sanna et al., 2024)​, otros proponen frameworks más amplios aplicables a múltiples entornos tecnológicos como Iot y Edge Computing.  

Los hallazgos en el campo de la ciberseguridad muestran que el uso de metodologías híbridas que combinan análisis estático y dinámico es efectivo para la detección de vulnerabilidades complejas ​(El-Zawawy & Hamdy, 2025)​. De igual manera, los resultados experimentales utilizados en la evaluación de herramientas de seguridad comprueban que el uso de frameworks conceptuales estructurados es fundamental para guiar el desarrollo seguro de aplicaciones (​Koman & Janiszewski, 2025; Lazarov et al., 2025)​. Hay coincidencias en el uso de aprendizaje automático y técnicas de análisis automatizado para la detección de malware, sin importar la plataforma específica de Android analizada ​(El-Zawawy & Hamdy, 2025; Samhi & Bartel, 2022; Sanna et al., 2024)​. 

Adicionalmente, múltiples investigaciones convergen en la necesidad de integrar análisis manual y automatizado para lograr una cobertura completa de vulnerabilidades, evidenciando que ningún enfoque individual es suficiente para abordar la complejidad de las amenazas modernas ​(Koman & Janiszewski, 2025; Lazarov et al., 2025)​. 

 

Conclusiones comparadas de la categoría Integración de seguridad y metodologías DevSecOps en el desarrollo móvil  

Mientras que Saeed et al. (2025) realizan una revisión sistemática que integra la seguridad en todas las fases del SDLC con métricas numéricas de riesgo y automatización de análisis de amenazas y pruebas, Casola et al. (2024) plantean una metodología basada en modelos que vincula el modelo de amenazas con la generación automática de planes de prueba para reducir la dependencia de expertos. A su vez, Shin et al. (2025) llevan estos principios al sector financiero con un framework Zero Trust adaptado a entornos cloud-native-DevSecOps, compuesto por 7 dominios y 23 subcategorías. En conjunto, estas investigaciones coinciden en que incorporar seguridad desde el inicio, automatizar procesos y aplicar principios de mínima confianza reduce costos de corrección, mejora la cobertura de vulnerabilidades y fortalece la gobernanza de la ciberseguridad.  

 

En el ámbito de pruebas móviles, Kuroishi et al. (2024) sintetizan 21 estudios secundarios en una taxonomía de 4 ejes y definen 15 desafíos de investigación que incluyen la generación automática de casos de pruebas y la falta de herramientas robustas. Por su parte, Pontillo et al. (2024) abordan la inestabilidad de pruebas (flakiness) desde la experiencia de los desarrolladores, identifican causas como fallos de interfaz, concurrencia y dependencias de red y proponen estrategias de refactorización. De forma complementaria, Alanazi y Alfayez (2024) analizan 176 876 preguntas de Stack Overflow para revelar que la instalación y la automatización de compilaciones en Flutter concentran las mayores dificultades y tiempos de respuesta. En conjunto, estos estudios destacan que la fragmentación de dispositivos, la volatilidad de las pruebas y los cuellos de botella en la automatización siguen siendo los principales retos para asegurar la calidad en aplicaciones móviles  

En el terreno de la inteligencia artificial aplicada a la ciberseguridad, Yang et al. (2025) proponen DLAP un framework que combina modelos de deep learning con técnicas de prompting en LLM para detectar vulnerabilidades con un desempeño cercano al fine-tuning pero con menor costo computacional. Este enfoque dialoga con las pruebas de Saeed et al. (2025) y Casola et al. (2024), que ya incorporan IA/ML, para automatizar el análisis de amenazas y pruebas de seguridad. En conjunto, estos trabajos muestran que la sinergia entre aprendizaje profundo, modelos de lenguaje y frameworks de desarrollo seguro permite una detección más eficiente y proceso de vulnerabilidades, siempre que se acompañe de una validación rigurosa y de la selección adecuada de técnicas por cada tipo de amenaza. 

 

Los hallazgos en el contexto de desarrollo seguro muestran que el uso de automatización es efectivo para reducir la dependencia de expertos y acelerar los procesos de seguridad ​(Casola et al., 2024; Saeed et al., 2025)​. De igual forma, los resultados experimentales en entornos DevSecOps comprueban que el uso de herramientas es fundamental para la integración continua de seguridad ​(Shin et al., 2025)​. Asimismo, hay coincidencias en identificar las limitaciones en las herramientas tradicionales para la detección de vulnerabilidades, no importando si se trata de enfoques VAPT generales o análisis específicos de Android ​(Casola et al., 2024; Palutla et al., 2025; Saeed et al., 2025)​. 

 

Conclusiones comparadas de la categoría Automatización inteligente y detección avanzada de vulnerabilidades Android 

 

​​Romdhana et al. (2023)​ identifican que las herramientas existentes detectan posibles vulnerabilidades, pero no pueden demostrar si son explotables porque no simulan las interacciones del usuario ni los mensajes internos necesarios. Esta problemática se amplifica en el trabajo de ​Amalfitano et al. (2025)​, quienes señalan que las herramientas se enfocan en el código o en la comunicación de red, pero no evalúan lo que ocurre en la pantalla mientras el usuario interactúa con la aplicación, generando el “problema del oráculo”. Ambos autores convergen en que existen una desconexión crítica entre la detección teórica y la confirmación práctica del riesgo real. Mientras ​Romdhana et al. (2023)​ proponen cerrar esta brecha mediante aprendizaje por refuerzo para automatizar la explotación, ​Amalfitano et al. (2025)​ trasladan las pruebas al nivel de interacción del usuario mediante pruebas metamórficas aplicadas a la GUI. Esta complementariedad metodológica, automatización inteligente versus validación basada en comportamiento observable, representa dos caminos convergentes hacia el mismo objetivo: demostrar la explotabilidad real de las vulnerabilidades detectadas. 

​​Molina-Coronado et al. (2023)​ demuestran que los detectores de malware se evalúan en condiciones optimistas que no reflejan escenarios reales, identificando cinco factores clave ignorados: presencia de muestras duplicadas, atribución de etiquetas inconsistente, desbalanceo de clases, técnicas de evasión y evolución temporal de aplicaciones. Esta crítica metodológica es reforzada sistemáticamente por ​Guerra-Manzanares (2024)​, quien desacredita la percepción de que la detección mediante Machine Learning es un problema resuelto, identificando cinco desafíos no resueltos: escasez de datasets actualizados y equilibrados, asunción errónea de consistencia en datos dinámicos, negligencia del concepto de drift, exploración superficial de seguridad de modelos ante ataques adversarios, y enfoque excesivo en rendimiento ignorando explicabilidad. Ambos trabajos coinciden en que las métricas de rendimiento reportadas son artificialmente altas debido a fallas de diseño experimental. ​Molina-Coronado et al. (2023)​ demuestran empíricamente caídas sustanciales cuando se introducen factores realistas, mientras que ​Guerra-Manzanares (2024)​ documenta estudios que muestran degradación del modelo por drift y vulnerabilidades adversarias. Esta convergencia evidencia una crisis de reproducibilidad y validez ecológica en la investigación de seguridad Android. 

 

​​D. Zhang et al. (2025)​ analizan el malware evasivo dinámico para Android que detecta entornos de análisis (emuladores, depuradores, herramientas de hooking) y altera su comportamiento para evadir detección, suprimiendo acciones maliciosas o entrando en estados dormidos, lo que genera trazas incompletas o engañosas aumentando falsos negativos. Este fenómeno se entrelaza directamente con los hallazgos de ​Senanayake et al. (2024)​, quienes identifican que las soluciones habituales no pueden aprovechar código privado para entrenar modelos por temas de confidencialidad, limitando el aprendizaje colectivo entre organizaciones. La evasión documentada por ​D. Zhang et al. (2025)​ se ve facilitada precisamente por esta incapacidad de compartir patrones de ataque entre organizaciones. Adicionalmente, ​Prasad et al. (2025)​ señalan desafíos en la detección de malware sofisticado debido a limitaciones de datasets existentes y falta de modelos escalables. ​D. Zhang et al. (2025)​ concluyen que ninguna contramedida cubre todas las evasiones y proponen análisis cross-layer, mientras que ​Senanayake et al. (2024)​ introducen aprendizaje federado para compartir modelos sin exponer código. Esta triangulación revela que enfrentar el malware evasivo requiere simultáneamente: diversificación de contramedidas, colaboración preservando privacidad y datasets robustos a escala. 

 

​​Vincenzi et al. (2025)​ identifican que el mutation testing en Android enfrenta un problema de alto costo y baja eficiencia, ya que generar, compilar e instalar cada mutante por separado requiere gran cantidad de recursos de tiempo, espacio y procesamiento, dificultando su aplicación en proyectos reales. Esta ineficiencia operativa contrasta con la propuesta de ​Senanayake et al. (2024)​, quienes señalan que las soluciones habituales llegan tarde (al final del ciclo) y proponen adelantar la verificación de seguridad a las primeras fases del desarrollo mediante detección en tiempo real dentro de Android Studio. Mientras ​Vincenzi et al. (2025)​ logran reducir costos mediante mutant schemata (99.78% menos espacio en disco, 8.5% más rápido en generación, 6.45% más rápido en ejecución), ​Senanayake et al. (2024)​ consiguen analizar una línea de código en aproximadamente 300 milisegundos con 96% de precisión. Ambos trabajos articulan el paradigma “shift-left” en testing de seguridad: ​Vincenzi et al. (2025)​ hace viable económicamente las pruebas exhaustivas por mutación que antes eran prohibitivas, mientras ​Senanayake et al. (2024)​ integra detección continua durante la escritura de código. Esta complementariedad representa dos estrategias esenciales para incorporar seguridad desde las etapas iniciales del desarrollo sin sacrificar viabilidad operativa. 

 

Conclusiones comparadas de Modelos de aprendizaje automático y detección inteligente de malware en Android 

Mientras que ​Muzaffar et al. (2025)​ con ActDroid centran su aporte en disminuir la dependencia de grandes volúmenes de datos etiquetados mediante un esquema de aprendizaje activo, alcanzando una precisión del 96.3% con solo el 30% de los datos, ​Gu et al. (2024)​ con GSEDroid se orientan hacia la reducción de la complejidad semántica del modelo a través de embeddings ligeros basados en grafos neuronales, logrando 97.32% de precisión y una compresión del 42% en los vectores. Mientras que el primero optimiza la cantidad y costo del etiquetado, el segunda mejora la calidad de la representación del conocimiento y la eficiencia computacional. En conjunto, ambos trabajos evidencian una tendencia convergente hacia la eficiencia escalable en la detección de malware Android, donde se busca mantener la precisión reduciendo los recursos humanos y técnicos necesarios para sostener modelos actualizado y adaptativos.  

Por un lado, ​He et al. (2026)​ con MCGDroid refuerzan la semántica técnica interna del código, integrando opcodes y llamadas a APIs sensibles dentro de grafos de clases para capturar patrones de comportamiento malicioso, alcanzando una precisión del 98.82% incluso ante muestras ofuscadas. Por otro lado, ​R. Arikkat et al. (2025)​ con DroidTTP trasladan el análisis hacia un plano táctico-conductual, vinculando las acciones de las aplicaciones con las técnicas y procedimientos (TTPs) del marco MITRE ATT&CK, logrando un 94.28% de precisión y reduciendo falsos positivos en 23%. Mientras el primero busca entender cómo actúa el malware dentro del código, el segundo busca entender por qué actúa, interpretando su intención operativa. Esta comparación revela una progresión metodológica: de la semántica estructural orientada a la ingeniería inversa, hacia una semántica contextual vinculada con la inteligencia artificial. Ambas aproximaciones se complementan al construir sistemas de detección más interpretativos, resilientes y difíciles de evadir.  

En el trabajo de ​S. Zhang et al. (2025)​, MPDroid propone una fusión multimodal que integra características estáticas y dinámicas mediante preentrenamiento conjunto, alcanzando 98.3% de precisión y reduciendo el tiempo de detección a 7.39 segundos, con el objetivo de superar el sesgo unimodal y permitir inferencia eficiente en una sola modalidad. En contraste, ​Yapici (2025)​ introduce un enfoque basado en imágenes, transformando el bytecode Dalvik en representaciones visuales (RGB y escala de grises), eliminando duplicados y balanceando clases, lo que incrementa la validez experimental y mejora la precisión hasta 98.7%. Mientras que el primero integra fuentes heterogéneas para aumentar la capacidad de generalización, el segundo limpia y reestructura los datos para mejorar la fiabilidad del aprendizaje. Ambos caminos confluyen en la búsqueda de una detección más robusta y generalizable, demostrando que la adaptabilidad del modelo puede lograrse tanto mediante la combinación de modalidad como mediante la depuración y reinterpretación del dato en sí.  

Conclusiones comparadas de Detección de Malware Android con Machine Learning y Técnicas Avanzadas 

​​Ma et al. (2024)​implementaron MCADS, un sistema de dos capas donde la primera utiliza MLP para analizar AndroidManifest.xml filtrando el 99.73% de aplicaciones, mientras la segunda emplea ShuffleNetV2-ECA para procesar imágenes DEX, logrando un modelo compacto de 30.43 MB con entrenamiento de 12.76 segundos por época. ​Z. Liu et al. (2024)​ desarrollaron MobiPCR bajo una arquitectura hibrida nube-Edge que integra ensemble dinámico DES-KNN, interceptando instalaciones con tiempos de 2.5 segundos y alcanzando 98.9% de precisión, superando a Avast Mobile Security en 15%. Ambos priorizan eficiencia en dispositivos móviles, pero MCADS sobresale en usabilidad practica al automatizar detección durante instalación sin intervención del usuario, evidenciando un balance entre comprensión visual versus interpretabilidad tradicional.  

 

​​Huang et al. (2023)​ propusieron WHGDroid basado en grafos heterogéneos ponderados con GraphSAGE, logrando 98.71% de precisión en AMD y efectividad contra zero-day 39% superior a MaMaDroid. ​Z. Liu et al. (2024)​ desarrollaron SeGDroid mediante grafos de llamadas sensibles con poda que preserva 21,986 APIs de PScout, alcanzando F-score de 98% y reduciendo nodos de 46,795 a 18,315. Por su parte, ​Soi et al. (2024)​ extrajeron APIs críticas del FCG usando TF-IDF e implementaron SHAP para explicabilidad, identificando lockNow() y resetPassword() en ransomware con 87% de accuracy. Las tres investigaciones aprovechan grafos para capturar comportamiento malicioso, pero WHGDroid enfatiza relaciones inter-aplicaciones, SeGDroid prioriza reducción de complejidad mediante poda inteligente y equilibran efectividad con interpretabilidad directa para analistas.  

 

 ​John et al. (2024b)​ presentaron EigenGVN capturando subgrafos maliciosos invariantes mediante clustering espectral que computa centralidades como Betweenness y PageRank, alcanzando 98.7% en malware común, 97.3% en ofuscado y 90% en mimetismo adversarial con FPR de 0.014. ​Nawshin et al. (2024)​ evaluaron integración de aprendizaje federado con encriptación holomórfica y k-anonimidad, logrando métodos híbridos con 98.57% de precisión en Drebin y superando clasificadores base en 16% de F1-score preservando privacidad sin compartir datos crudos. ​Ullah et al. (2024)​ utilizaron XAI con SHAP y LIME para explicar decisiones de CNN-LSTM que alcanzo 99.48% de precisión, revelando que Features 4 y 2 contribuyen a detectar malware mientras Features 12 y 18 identifican aplicaciones seguras. EigenGVN y Nawshin et al. Abordan robustez técnica contra evasiones y protección de datos sensibles respectivamente, mientras ​Ullah et al. (2024)​ expone limitaciones críticas al demostrar que alta precisión en laboratorio (99.48%) se debe a patrones temporales y no a compresión de comportamientos maliciosos reales, señalando necesidad de cambiar enfoque desde exactitud hacia sistemas confiables y aplicables.  	 

 

Conclusiones generales  

Los artículos más influyentes para futuras investigaciones en ciberseguridad incluyen: 

 

​​Koman & Janiszewski (2025)​ por su contribución metodológica que establece un estándar para evaluar herramientas DAST, relevando las limitaciones significativas de los escáneres actuales (efectividad máxima de 3,8%) y proporcionando un framework replicable para futuras evaluaciones de herramientas de seguridad. 

 

​​El-Zawawy & Hamdy (2025)​ por demostrar la viabilidad de detectar vulnerabilidades complejas de escalamiento de privilegios mediante técnicas de machine Learning, identificando 52,982 casos previamente invisibles y alcanzando 100% de precisión en resolución de intents. 

​​Lazarov et al. (2025)​ por su enfoque integral que supera significativamente a herramientas establecidas como Burp Suite (35 vs 17 vulnerabilidades detectadas en OWASP Juice Shop), demostrando la superioridad de metodologías que combinan análisis automatizado con validación manual estructurada. 

​​Saeed et al. (2025)​ por aportar una revisión sistemática que integra la seguridad en todas las fases del ciclo del software, proponiendo métricas numéricas para priorizar riesgos y destacando la automatización de análisis de amenazas y pruebas como base para reducir costos, correcciones y aumentar la cobertura de vulnerabilidades.  

​​Kuroishi et al. (2024)​ por ofrecer una panorámica completa del estado de las pruebas de aplicaciones móviles mediante un estudio que sintetiza 21 revisiones, define una taxonomía de 4 ejes y plantea una agenda de 15 desafíos para guiar futuras investigaciones de automatización, context-awareness y herramientas de prueba. 

​​Yang et al. (2025)​ por presentar un framework DLAP, que combina deep learning y técnicas de prompting en modelos de lenguaje de gran tamaño para detectar vulnerabilidades con precisión cercana al fine-tuning pero con menor costo computacional, abriendo una vía prometedora para integrar inteligencia artificial en el desarrollo seguro de software.  

​​Guerra-Manzanares (2024)​ por su revisión exhaustiva que desacredita la percepción de que la detección de malware mediante Machine Learning es un problema resuelto, identificando cinco desafíos estructurales no resueltos: escasez de datasets actualizados y equilibrados, inconsistencias en datos dinámicos entre plataformas, negligencia del concepto de drift temporal, vulnerabilidad a ataques adversarios y ausencia de explicabilidad. Su trabajo establece el marco crítico necesario para evaluar rigurosamente cualquier propuesta futura y propone direcciones concretas como datasets representativos, manejo explícito de drift y XAI para interpretabilidad.  

​​Molina-Coronado et al. (2023)​ por proporcionar evidencia empírica definitiva mediante la reimplementación de 10 detectores state-of-the-art bajo un marco común, demostrando que los rendimientos optimistas se deben a fallas de diseño experimental. Su análisis cuantifica el impacto de cinco factores realistas (duplicados, etiquetado inconsistente, desbalanceo, técnicas de evasión y evolución temporal) que generan caídas sustanciales en rendimiento, haciendo los resultados irrelevantes para despliegue real. La liberación de código y datasets en GitLab establece un precedente de transparencia y reproducibilidad que transforma la crítica en herramientas accionables.  

​​D. Zhang et al. (2025)​ por unificar estrategias de evasión de malware en una taxonomía contextual innovadora que clasifica evasiones según tipos de entornos de análisis y condiciones de activación (trigger-condition). Su revisión sistemática abarca análisis temporal de evolución de técnicas evasivas y comparación de contramedidas en tres dominios: optimización de entornos de análisis, identificación de malware evasivo y exploración de comportamientos maliciosos. Revelan que ninguna contramedida individual cubre todas las evasiones e identifican cinco desafíos clave, proponiendo direcciones futuras como análisis cross-layer, XAI para evaluaciones de IA y datasets especializados que establecen la agenda de investigación para la próxima década.  

​​Romdhana et al. (2023)​ por introducir RONIN, el primer sistema que demuestra la viabilidad de automatizar completamente la verificación y explotación de vulnerabilidades en Android mediante aprendizaje por refuerzo profundo (Soft Actor-Critic). Su contribución establece un nuevo paradigma al cerrar la brecha entre detección teórica y confirmación práctica mediante un agente de IA que aprende autónomamente a generar Intents correctos para explotar fallas. Con resultados contundentes de explotación del 100% de vulnerabilidades en conjuntos de prueba y generación de tres veces más exploits únicos que Letterbomb en 1,500 aplicaciones demuestran que la IA puede trascender la clasificación para convertirse en un agente de razonamiento estratégico, abriendo la puerta a sistemas de seguridad adaptativos que superan enfoques basados en reglas estáticas.  

​​He et al. (2026)​ destacan por consolidar un nuevo estándar en la clasificación de malware Android al integrar múltiples atributos semánticos dentro de grafos de llamadas entre clases, alcanzando una combinación excepcional de precisión (98.92%) y resiliencia ante ofuscación. Su propuesta, MCGDroid, no solo resuelve la dualidad entre complejidad estructura y rendimiento, sino que demuestra empíricamente que es posible preservar la semántica del comportamiento malicioso sin sacrificar velocidad ni recursos computacionales. Este equilibrio redefine el diseño de los modelos estáticos al ofrecer una arquitectura reproducible, escalable y robusta frente a la evasión. Además, su validación exhaustiva con datasets reales (CICMalDroid-2020) siente un precedente de rigurosidad experimental, estableciendo las bases para detectores explicables, eficientes y resistentes en el ecosistema Android.  

​​R. Arikkat et al. (2025)​ transforman la detección de malware con DroidTTP, al vincular comportamientos de las aplicaciones con las tácticas y procedimientos (TTPs) del marco MITRE ATT&CK. Este enfoque introduce una inteligencia de amenazas contextual y automatizada, capaz de reconocer intenciones maliciosas ocultas tras APIs legitimas. Con una reducción de 23% en falsos positivos, DroidTTP impulsa la evolución desde la detección técnica hacia una comprensión táctica y estratégica de los ataques en Android.  

 ​S. Zhang et al. (2025)​ con MPDroid integran de forma innovadora características estáticas y dinámicas mediante aprendizaje multimodal preentrenado, logrando 98.3% de precisión con tiempos de detección reducidos. Su aporte clave es demostrar que la fusión de modalidades heterogéneas puede superar las limitaciones del análisis unimodal, generando modelos más generales, rápidos y adaptativos. Esta propuesta consolida el tránsito hacia una detección móvil inteligente y autónoma, adaptable al ritmo cambiante del malware.  

​​Ma et al. (2024)​ demostraron que arquitecturas en cascada logran balance optimo entre rendimiento y recursos mediante MCADS, procesando 99.73% de aplicaciones en primera capa y generando un sistema de 30.43 MB versus 66.96 MB de EfficientNet-B4 con tiempo de entrenamiento reducido de 12.76s por época. Este enfoque valida que detección móvil efectiva no requiere modelos masivos sino arquitecturas inteligentes que filtren progresivamente amenazas, estableciendo que mejor complejidad genera mayor viabilidad operacional en dispositivos con recursos limitados.  

​​Ullah et al. (2024)​ revelaron mediante XAI que modelos CNN-LSTM alcanzando 99.48% de precisión aprenden patrones temporales en lugar de comportamientos maliciosos reales, exponiendo que métricas de laboratorio no garantizan efectividad práctica. Esta investigación transforma el paradigma desde “que tan preciso es el modelo” hacia “por qué el modelo toma esas decisiones” para asegurar detección confiable en entornos reales.  

​​Nawshin et al. (2024)​ demostraron que aprendizaje federado con encriptación holomórfica alcanza 98.57% de precisión preservando privacidad sin compartir datos crudos, superando clasificadores de base en 16% de F1-score. Este avance valida que protección de información y efectividad de detección son objetivos complementarios, critico ante pérdidas estimadas por ransomware de 10.5 billones de dólares para 2025.  

 

Referencias bibliográficas 

 

​​Alanazi, A., & Alfayez, R. (2024). What is discussed about Flutter on Stack Overflow (SO) question-and-answer (Q&A) website: An empirical study. Journal of Systems and Software, 215, 112089. https://doi.org/https://doi.org/10.1016/j.jss.2024.112089  

​Amalfitano, D., Júnior, M., Fasolino, A. R., & Delamaro, M. (2025). A GUI-based Metamorphic Testing Technique for Detecting Authentication Vulnerabilities in Android Mobile Apps. Journal of Systems and Software, 224, 112364. https://doi.org/10.1016/J.JSS.2025.112364  

​Casola, V., De Benedictis, A., Mazzocca, C., & Orbinato, V. (2024). Secure software development and testing: A model-based methodology. Computers & Security, 137, 103639. https://doi.org/10.1016/J.COSE.2023.103639  

​El-Zawawy, M. A., & Hamdy, A. (2025). Detection of hidden privilege escalations in android. Automated Software Engineering, 32(2). https://doi.org/10.1007/s10515-025-00542-4  

​Gu, J., Zhu, H., Han, Z., Li, X., & Zhao, J. (2024). GSEDroid: GNN-based Android malware detection framework using lightweight semantic embedding. Computers & Security, 140, 103807. https://doi.org/10.1016/J.COSE.2024.103807  

​Guerra-Manzanares, A. (2024). Machine Learning for Android Malware Detection: Mission Accomplished? A Comprehensive Review of Open Challenges and Future Perspectives. Computers & Security, 138, 103654. https://doi.org/10.1016/J.COSE.2023.103654  

​He, M., Ge, J., Chen, Z., Ling, J., & Kong, W. (2026). MCGDroid: An android malware classification method based on multi-feature class-call graph characterization. Computers & Security, 160, 104713. https://doi.org/10.1016/J.COSE.2025.104713  

​Huang, L., Xue, J., Wang, Y., Liu, Z., Chen, J., & Kong, Z. (2023). WHGDroid: Effective android malware detection based on weighted heterogeneous graph. Journal of Information Security and Applications, 77, 103556. https://doi.org/10.1016/J.JISA.2023.103556  

​John, T. S., Thomas, T., & Emmanuel, S. (2024). Detection of Evasive Android Malware Using EigenGCN. Journal of Information Security and Applications, 86, 103880. https://doi.org/10.1016/J.JISA.2024.103880  

​Kincl, J., Eftimov, T., Viktorin, A., Šenkeřík, R., & Pavleska, T. (2025). Comprehensive benchmarking of knowledge graph embeddings methods for Android malware detection. Expert Systems with Applications, 288, 127888. https://doi.org/10.1016/J.ESWA.2025.127888  

​Koman, J., & Janiszewski, M. (2025). SCAnME - scanner comparative analysis and metrics for evaluation. International Journal of Information Security, 24(3). https://doi.org/10.1007/S10207-025-01054-8  

​Kuroishi, P. H., Maldonado, J. C., & Vincenzi, A. M. R. (2024). Towards the definition of a research agenda on mobile application testing based on a tertiary study. Information and Software Technology, 167, 107363. https://doi.org/https://doi.org/10.1016/j.infsof.2023.107363  

​Lazarov, W., Seda, P., Martinasek, Z., & Kummel, R. (2025). Penterep: Comprehensive penetration testing with adaptable interactive checklists. Computers and Security, 154. https://doi.org/10.1016/J.COSE.2025.104399  

​Liu, C., Lu, J., Feng, W., Du, E., Di, L., & Song, Z. (2023). MobiPCR: Efficient, accurate, and strict ML-based mobile malware detection. Future Generation Computer Systems, 144, 140–150. https://doi.org/10.1016/J.FUTURE.2023.02.014  

​Liu, Z., Wang, R., Japkowicz, N., Gomes, H. M., Peng, B., & Zhang, W. (2024). SeGDroid: An Android malware detection method based on sensitive function call graph learning. Expert Systems with Applications, 235, 121125. https://doi.org/10.1016/J.ESWA.2023.121125  

​Ma, R., Yin, S., Feng, X., Zhu, H., & Sheng, V. S. (2024). A lightweight deep learning-based android malware detection framework. Expert Systems with Applications, 255, 124633. https://doi.org/10.1016/J.ESWA.2024.124633  

​Mohanraj, A., & Sivasankari, K. (2024). Android traffic malware analysis and detection using ensemble classifier. Ain Shams Engineering Journal, 15(12), 103134. https://doi.org/10.1016/J.ASEJ.2024.103134  

​Molina-Coronado, B., Mori, U., Mendiburu, A., & Miguel-Alonso, J. (2023). Towards a fair comparison and realistic evaluation framework of android malware detectors based on static analysis and machine learning. Computers & Security, 124, 102996. https://doi.org/10.1016/J.COSE.2022.102996  

​Muzaffar, A., Hassen, H. R., Zantout, H., & Lones, M. A. (2025). ActDroid: An active learning framework for Android malware detection. Computers & Security, 104724. https://doi.org/10.1016/J.COSE.2025.104724  

​Nawshin, F., Gad, R., Unal, D., Al-Ali, A. K., & Suganthan, P. N. (2024). Malware detection for mobile computing using secure and privacy-preserving machine learning approaches: A comprehensive survey. Computers and Electrical Engineering, 117, 109233. https://doi.org/10.1016/J.COMPELECENG.2024.109233  

​Palutla, D. V., Bojjagani, S., Mula, S. C. R., Uyyala, R., Sharma, N. K., Morampudi, M. K., & Khan, M. K. (2025). Unveiling Android security testing: A Comprehensive overview of techniques, challenges, and mitigation strategies. Computers and Electrical Engineering, 127, 110620. https://doi.org/10.1016/J.COMPELECENG.2025.110620  

​Pontillo, V., Palomba, F., & Ferrucci, F. (2024). Test Code Flakiness in Mobile Apps: The Developer’s Perspective. Information and Software Technology, 168, 107394. https://doi.org/https://doi.org/10.1016/j.infsof.2023.107394  

​Prasad, A., Chandra, S., Alenazy, W. M., Ali, G., Shah, S., & ElAffendi, M. (2025). AndroMD: An Android malware detection framework based on source code analysis and permission scanning. Results in Engineering, 28, 107050. https://doi.org/10.1016/J.RINENG.2025.107050  

​R. Arikkat, D., Vinod, P., Rehiman K.A., R., Nicolazzo, S., Arazzi, M., Nocera, A., & Conti, M. (2025). DroidTTP: Mapping android applications with TTP for Cyber Threat Intelligence. Journal of Information Security and Applications, 93, 104162. https://doi.org/10.1016/J.JISA.2025.104162  

​Reyes-Acosta, R. E., Mendoza-González, R., Oswaldo Diaz, E., Vargas Martin, M., Luna Rosas, F. J., Martínez Romo, J. C., & Mendoza-González, A. (2025). Cybersecurity Conceptual Framework Applied to Edge Computing and Internet of Things Environments. Electronics (Switzerland), 14(11). https://doi.org/10.3390/electronics14112109  

​Romdhana, A., Merlo, A., Ceccato, M., & Tonella, P. (2023). Assessing the security of inter-app communications in android through reinforcement learning. Computers & Security, 131, 103311. https://doi.org/10.1016/J.COSE.2023.103311  

​Saeed, H., Shafi, I., Ahmad, J., Khan, A. A., Khurshaid, T., & Ashraf, I. (2025). Review of Techniques for Integrating Security in Software Development Lifecycle. Computers, Materials and Continua, 82(1), 139–172. https://doi.org/https://doi.org/10.32604/cmc.2024.057587  

​Samhi, J., & Bartel, A. (2022). On The (In)Effectiveness of Static Logic Bomb Detection for Android Apps. IEEE Transactions on Dependable and Secure Computing, 19(6), 3822–3836. https://doi.org/10.1109/TDSC.2021.3108057  

​Sanna, S. L., Soi, D., Maiorca, D., Fumera, G., & Giacinto, G. (2024). A risk estimation study of native code vulnerabilities in Android applications. Journal of Cybersecurity, 10(1). https://doi.org/10.1093/cybsec/tyae015  

​Senanayake, J., Kalutarage, H., Petrovski, A., Piras, L., & Al-Kadri, M. O. (2024). Defendroid: Real-time Android code vulnerability detection via blockchain federated neural network with XAI. Journal of Information Security and Applications, 82, 103741. https://doi.org/10.1016/J.JISA.2024.103741  

​Shin, D., Kim, J., Pawana, I. W. A. J., & You, I. (2025). Enhancing cloud-native DevSecOps: A Zero Trust approach for the financial sector. Computer Standards & Interfaces, 93, 103975. https://doi.org/10.1016/J.CSI.2025.103975  

​Soi, D., Sanna, A., Maiorca, D., & Giacinto, G. (2024). Enhancing android malware detection explainability through function call graph APIs. Journal of Information Security and Applications, 80, 103691. https://doi.org/10.1016/J.JISA.2023.103691  

​Ullah, S., Li, J., Ullah, F., Chen, J., Ali, I., Khan, S., Ahad, A., & Leung, V. C. M. (2024). The revolution and vision of explainable AI for Android malware detection and protection. Internet of Things, 27, 101320. https://doi.org/10.1016/J.IOT.2024.101320  

​Vincenzi, A. M. R., Kuroishi, P. H., Bispo, J., da Veiga, A. R. C., da Mata, D. R. C., Azevedo, F. B., & Paiva, A. C. R. (2025). METFORD – Mutation tEsTing Framework fOR anDroid. Journal of Systems and Software, 222, 112332. https://doi.org/10.1016/J.JSS.2024.112332  

​Yang, Y., Zhou, X., Mao, R., Xu, J., Yang, L., Zhang, Y., Shen, H., & Zhang, H. (2025). DLAP: A Deep Learning Augmented Large Language Model Prompting framework for software vulnerability detection. Journal of Systems and Software, 219, 112234. https://doi.org/10.1016/J.JSS.2024.112234  

​Yapici, M. M. (2025). A novel image based approach for mobile android malware detection and classification. Knowledge-Based Systems, 323, 113855. https://doi.org/10.1016/J.KNOSYS.2025.113855  

​Zaitseva, E., Hovorushchenko, T., Pavlova, O., & Voichur, Y. (2023). Identifying the Mutual Correlations and Evaluating the Weights of Factors and Consequences of Mobile Application Insecurity. Systems, 11(5). https://doi.org/10.3390/systems11050242  

​Zhang, D., Yang, X., Liu, S., Zhou, Y., Fu, J., & Peng, G. (2025). A survey on Android dynamic evasive malware: Taxonomy, countermeasures and open challenges. Computers & Security, 159, 104646. https://doi.org/10.1016/J.COSE.2025.104646  

​Zhang, S., Su, H., Liu, H., & Yang, W. (2025). MPDroid: A multimodal pre-training Android malware detection method with static and dynamic features. Computers & Security, 150, 104262. https://doi.org/10.1016/J.COSE.2024.104262  

​Zhu, H., Wei, H., Wang, L., Xu, Z., & Sheng, V. S. (2023). An effective end-to-end android malware detection method. Expert Systems with Applications, 218. https://doi.org/10.1016/J.ESWA.2023.119593  

​ ​ 
